Terminology
-----------

Throughout this document we will use terminology described in the "Glossary":http://dev.webinos.org/redmine/projects/wp3-3/wiki/Glossary from ([[D036_References#Webinos-D33|Webinos-D33]]). In particular we reference:

-   Security goals, such as confidentiality, integrity, availability and accountability.
-   Access control terms, such as authorisation, authentication and identification.
-   Privacy goals, such as anonymity, unlinkability, undetectability, unobservability and pseudonymity.

We would also like to draw the readers attention to the following definitions which are important for the understanding of this document:

### Architectural Risk analysis terms

  ---------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _.Term                  _.Definition
  Ambiguity Analysis           This activity involves eliciting undesirable behaviour resulting from ambiguity or inconsistency in the software architecture.
  Architectural Pattern        These express a model of part of a software system, pre-defined sub-systems, responsibilities, and guidelines for organising the relationships between model elements.
  Attack pattern               Attack patterns are descriptions of common methods for exploiting software that both provide an attacker’s perspective, together with guidance towards mitigating them.
  Attack Resistance Analysis   This identifies general flaws from the literature and knowledge basis of known attacks and, based on these, identifies potential risks and their viability.
  CAIRIS                       CAIRIS (Computer Aided Integration of Requirements and Information Security) is a Requirements Management tool for specifying secure and usable systems. This tool was developed at the University of Oxford and has been extended during the project to support the webinos design process.
  Goal model                   Goals describe the objectives that a system aims to achieve when it has been fully developed. A goal model is an artefact used in goal-oriented requirements engineering to link high-level goals to the sub-goals that the can be refined to. Meeting a high-level goal may require meeting one or more of the sub-goals. Goal trees provide a way to structure the requirements of a system and trace the rationale behind goals. They also allow for individual sub-goals to be assigned to responsible parties.
  Obstacle model               Obstacles are undesirable behaviours which a system aims to avoid. An obstacle model is the logical inverse of a goal tree. It defines a set of behaviours which prevent a goal from being met.
  Weakness analysis            This identifies weaknesses that might arise in a system due to the impact of the architecture’s dependencies.
  ---------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Trust

  ------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _.Term   _.Definition
  Trusted       Alice believes that Bob is ‘trusted’ if she believes that Bob will behave in the way she expects, not violating her security or privacy requirements. Similarly, an application is ‘trusted’ if the user believes that it will behave in the expected manner and not violate their security or privacy requirements. Generally the notion of trusting an entity only occurs when the entity has the ability (but hopefully not the intention) to abuse that trust. We aim to limit the number of components in webinos that are trusted while carefully documenting how each component is trusted and what for.
  Trustworthy   An entity is trustworthy if it _will_ behave as expected. For example, an application which is granted access to user location data is trusted by that user to not misuse that data. The application is _trustworthy_ if it uses the data in the way the user expects. This might mean not sharing it with a third party, or not storing it at all.
  Trustable     An entity is trustable if sufficient information is available in order to work out whether it is trustworthy. For example, a website being served over HTTP is arguably not _trustable_ because we cannot authenticate whether it is the website it says it is. It may be being spoofed by another party. In comparison, a website served over HTTPS with a certificate from a trusted authority is more _trustable_ because they can be identified. Being trustable is a necessary condition for establishing that an entity is trustworthy, but not sufficient. The website served over HTTPS still may be untrustworthy. Another example is a downloaded application. It might be considered trustable if its integrity and authenticity is checked (e.g., it is signed and the signature is verified before execution) and if it is running on a platform that is trusted. If these conditions do not hold, then the same application might have been modified by an attacker or might be running on a malicious platform altering its behaviour.
  ------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


