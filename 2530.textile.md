Spec - Access Control Policy
============================

Policy Format
-------------

Webinos’ policies are expressed in the simplified XACML format defined for the first time in "BONDI’s Architecture & Security Requirements (Appendices) v1.1" ([[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]]) and following the grammar provided by WAC ([[Spec_-_Access_Control_Policy#WACXMLSP|WACXMLSP]]). This format has been used as a basis in different specifications as W3C DAP ([[Spec_-_Access_Control_Policy#DAPWG|DAPWG]]) and WAC ([[Spec_-_Access_Control_Policy#WACDS|WACDS]]).
Starting from the same format some changes are introduced to fulfill webinos’ requirements due to the different structures and aims of the mentioned frameworks.

The main updates to the BONDI policy format are:
* Some new attributes related to the subject’s information to fit webinos’ requirements for distribution of policies between devices and cross device interaction.
* Two new attributes related to the resource’s information required to identify services and the extensions that could be declared in an application manifest.
* Privacy policy elements that are discussed in the [[Spec_-_Privacy_Policy]] subsection.

h2. Application execution phases

As defined also in [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] (B.2) the execution phase of an application reflects the state of that application at the time an associated access control query is made.

  --------------------- -------------------------------------------------------------------------------------------------------------------------------------
  **Execution phase**   **Definition**
  widget-install        Applies to access control queries made during an installation or update process.
  widget-instantiate    Applies to access control queries made during the instantiation of a widget.
  website-bind          Applies to access control queries made in response to a feature request during the execution of a website
  invoke                Applies to access control queries made in response to each invocation of a javascript API during the execution of a web Application
  --------------------- -------------------------------------------------------------------------------------------------------------------------------------

Is there a state machine for this?

Policy Subject
--------------

Given a policy, the policy subject define the entity to which the policy will be applied. The set of subjects to which the policy or policy set applies is called target.

Each subject respects the following template:

"User U can access Feature F of Device D through the application A running in a Device X"

"Device D" is also identified as target device whilst the "Device X" is identified as requestor device.

There are four basic information points in this template:

1.  WHO want to access a resource: could be an user or a list of users
2.  WHERE the access requestor is: it should be possible to differentiate a local access (INTRA-DEVICE) from a remote access (INTRA-PZ or EXTRA-PZ)
3.  WHERE the resource is: allow the same policy file to be used by many devices
4.  WHICH application is used: could be used to differentiate behaviour for applications from different authors, distributors, and other attributes

It’s possible that some or all subject’s attributes are not specified in a given subject. In these cases, the default values will be used to represent missing information.

Subject Attributes
------------------

The subject attributes are divided in three groups:

1.  Apps
2.  Devices
3.  User

### Apps attributes

This needs to correspond to the ‘types of applications’ defined in Entity Definitions. => [SM] done

The first group comes from the "B.4 Subject Attributes" section of ([[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]]) and defines the properties used to identify widgets and browser-based applications.
In case of widgets, recognized or unrecognised (see [[Entity_Definitions#Webinos-application|Webinos application]]), the attributes are:

  ---------------------------------- ------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _.Attribute                   _.Type   _.Value
  class                              String        This has the value "w-r" or "w-u" if and only if the subject is respectively a recognized widget or an unrecognized one.
  install-uri                        URI           The URI that the Widget Resource was originally retrieved from before installation, if known, otherwise the empty bag.
  id                                 URI           The identity of the Widget. For a W3C Widget specification compliant Widget Resource, this is the value of the id attribute of the <widget> element in the Widget Configuration Document converted from IRI to URI based on RFC3987. In this case, it is a URI that uniquely identifies the Widget. Empty bag if there is no id attribute.
  version                            String        Version of the Widget Resource. For a W3C Widget specification compliant Widget Resource, this is the version attribute of the <widget> element in the Widget Configuration Document. Empty bag if there is no version attribute.
  distributor-key-cn                 String        The common name of the end entity certificate for the applicable Widget Resource distributor signature. Empty bag if none.
  distributor-key -fingerprint       String        The fingerprint of the end-entity certificate for the applicable Widget Resource distributor signature. Empty bag if none.
  distributor-key-root-cn            String        The common name of the root certificate for the applicable Widget Resource distributor signature. Empty bag if none.
  distributor-key-root-fingerprint   String        The fingerprint of the root certificate for the applicable Widget Resource distributor signature.Empty bag if none.
  author-key-cn                      String        The common name of the end entity certificate for the Widget Resource author signature. Empty bag if none.
  author-key-fingerprint             String        The fingerprint of the end entity certificate for the Widget Resource author signature in SDP syntax. Empty bag if none.
  author-key-root-cn                 String        The common name of the root certificate for the Widget Resource author signature. Empty bag if none.
  author-key-root-fingerprint        String        The fingerprint of the root certificate for the Widget Resource author signature. Empty bag if none.
  widget-attr:name                                 The value of the named attribute of the <widget> element whose type and value are set up in the Widget Configuration Document for use in the security framework. Empty bag if no such named attribute is defined.
  ---------------------------------- ------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

In case of browser-based applications the attributes are:

  ---------------------- ------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _.Attribute       _.Type   _.Value
  class                  String        This has the value "b-a" if and only if the subject is a browser-based authenticated application.
  sign-schema            String        The value will be â€œâ€ (empty string) or "tlsâ€ if the page was fetched using HTTPS and the browser has verified that the site certificateâ€™s Common Name matches the host that the page was fetched from, and it has already applied its own policies regarding whether the root certificate is in an acceptable trust domain. â€œtls-evâ€ if as â€œtlsâ€, and, additionally, the site certificate has an extended validation field and the browser’s internal policy allows that information to be passed to the security framework.
  uri                    URI           The URI used to access the document that embeds or refers to the JavaScript code, corresponding to the window.location property of the browsing context. In the case of that a Feature is accessed from a child browsing context (for example from within a <iframe> within some outer document), this attribute provides the location of the child context.
  uri-top                URI           The URI used to access the Website that embeds or refers to the JavaScript code, corresponding to the top.window property of the browsing context. In the case that the Feature is accessed from a child browsing context (for example from within an <iframe>), this attribute provides the location of the top-level browsing context. If the current browsing context is a child of a Widget top-level browsing context, this attribute contains an IRI with the widget: scheme that corresponds to the top-level containing document from the Widget Resource.
  key-root-cn            String        The common name of the root certificate chained to by the site certificate.
  key-root-fingerprint   String        The fingerprint of the root certificate chained to by the site certificate.
  ---------------------- ------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The attributes "id", "uri" and "uri-top" other than the values presented (defined also in [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]]) could contain one of the following URIs:

* http://webinos.org/subject/id/known
* http://webinos.org/subject/id/unknown

respectively if the widgets and browser-based applications were previously installed or not. If none of the apps attributes is specified then will be used the default value representing any widget/browser-based application:

* http://webinos.org/subject/id/any

**Note:** Browser-based applications can access webinos only if they are served from an origin with scheme HTTPS (see [[Application_Security_and_Secure_Communication#22-First-use-of-a-browser-based-application|First use of a browser based application]] for further details)

p(rev). What are these supposed to imply? "Trusted" is a dangerous term… => [SM] changed to known/unknow plus explanation

h3. Devices attributes

Devices attributes are used in order to express whether a device acts as a requestor or is a target, specifying its ID, domain and whether it is webinos enabled.
If the target-id is absent then the target device will be the "current device" and in a similar way if the requestor-id is absent the requestor will be the "current device".
The "current device" is the device that enforces the policy.

|_.Attribute |_.Type |_.Value|
|target-id |URI |ID of the device where the policy will be enforced. An ID could be a generic device URI (see list below) or refer to [[Entity_Definitions|Entity Definitions]] and [[Authentication|Authentication]] sections|
|target-domain |URI |Domain of the target device. Refer to the domain URIs listed below|
|requestor-id |URI |ID of the device requesting resources. An ID could be a generic device URI (see list below) or a PZP generated one|
|requestor-domain|URI |Domain of the requestor device. Refer to the domain URIs listed below|
|webinos-enabled |Boolean |True if requestor device is webinos enabled. If this attribute is not specified doesn’t matter if the device is webinos enabled or not|

p(rev). What is a PZP-generated device ID? => [SM] added reference to [[Entity_Definitions|Entity Definitions]] and [[Authentication|Authentication]] sections

p(rev). Do we need to have the ’webinos-enabled’ option? Which use-cases does it support?

_**Generic device URIs:**_
* http://webinos.org/subject/id/device
* http://webinos.org/subject/id/known
* http://webinos.org/subject/id/unknown
* http://webinos.org/subject/id/any (default)

In this context these URIs represent respectively the current device, a device whose certificate is already known, a device whose certificate is currently unknown and any device.

p(rev). What does ’trusted’ mean in this context? => [SM] changed to known/unknow plus explanation

_**Domain URIs:**_
* http://webinos.org/subject/domain/automotive
* http://webinos.org/subject/domain/desktop
* http://webinos.org/subject/domain/home-media
* http://webinos.org/subject/domain/mobile

http://webinos.org/subject/domain/any is the default domain URI value and represents all domains.


h3. User attributes

The User attributes allow to define the user to which a policy is referred. If the user-id is absent then the subject refers to any user.

|_.Attribute |_.Type |_.Value|
|user-id |URI |ID of the user to which the policy will be applied. An ID could be a generic user URI (see list below) or refer to [[Entity_Definitions|Entity Definitions]] and [[Authentication|Authentication]] sections |
|user-key-cn |String |The common name of the certificate for the user signature |
|user-key-fingerprint |String |The fingerprint of the certificate for the user signature |
|user-key-root-cn |String |The common name of the root certificate for the user signature |
|user-key-root-fingerprint|String |The fingerprint of the root certificate for the user signature |

_**Generic user URIs:**_
* http://webinos.org/subject/id/device
* http://webinos.org/subject/id/known
* http://webinos.org/subject/id/unknown
* http://webinos.org/subject/id/any (default)

In this context these URIs represent respectively the owner of the current device, an user whose certificate is already known, an user whose certificate is currently unknown and any user.


p(rev). What does ’trusted’ mean in this context? Can we distinguish between ’trusted’ and ’known’ ? => [SM] changed to known/unknow plus explanation

p(rev). What is a PZP-generated user ID? => [SM] added reference to [[Entity_Definitions|Entity Definitions]] and [[Authentication|Authentication]] sections


h2. Resource Attributes

In order to control the utilization of third party developers extensions, as defined in the [[Extensions background]] section of this document, the last two attributes of the following table are introduced to complete the list defined in "B.5 Resource Attributes" section of ([[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]]):

What extensions?

  ------------------------------ ------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _.Attribute               _.Type   _.Value
  api-feature                    URI           The Identifier of the requested feature
  device-cap                     String        The Identifier of the device capability being accessed
  param:name                     See comment   The value of parameter â€œnameâ€. This value is determined only in the invoke execution phase
  feature-install-uri            URI           The URI that the API implementation was originally retrieved from before installation
  feature-key-cn                 String        The common name of the end entity certificate for the signature associated with the feature implementation
  feature-key-root-cn            String        The common name of the root certificate for the signature associated with the feature implementation
  feature-key-root-fingerprint   String        The fingerprint of the root certificate of the signature associated with the feature implementation
  service                        URI           URI that identifies the service
  app-extension                  URI           URI that identifies the extension. If for the extension is not defined an URI, this will be composed by the application URI followed by the name of the extension (using percent-encoding for special characters [[Spec_-_Access_Control_Policy#RFC3986
  ------------------------------ ------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The attributes "service" and "app-extension" could contain one of the following URIs:
* http://webinos.org/resource/info/id/trusted
* http://webinos.org/resource/info/id/not-trusted

Attribute match
---------------

The attribute match statement comes from section B.7 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification. It represents the evaluation of an attribute against a value and can return true, false or indetermined as result.

An attribute match takes the name of subject match or resource match respectively if the attribute being evaluated is a subject or a resource attribute.

An attribute match statement can be represented by the following functions:

<pre><code class="javascript">
 matchfunc( modifierfunc( attr ), value )
</code></pre>

<pre><code class="javascript">
 matchfunc( attr, value )
</code></pre>

Where `matchfunc` is the matching function that requires two non-boolean inputs and whose result is a boolean or is undetermined if at least one input is undetermined.
The `modifierfunc` is a function that operates on a non-boolean input and whose result is a non-boolean value or is undetermined if its input is undetermined.


h2. Subject specification

The subject specification element comes from section B.8 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification. It consists of a conjunctive sequence of subject matches. A subject specification is evaluated as follows:
* is determined and has value TRUE if each of the subject matches has value TRUE
* otherwise, is undetermined if any or the subject matches is undetermined
* otherwise is determined and has value FALSE.

A subject match is an attribute match where the attribute being matched is a subject attribute, and the match value is a literal string.

Target
------

The target element comes from section B.9 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification. The target of a policy or policy set identifies the set of subjects to which the policy or policy set applies. It consists of a disjunctive sequence of subject specifications and is evaluated as follows:
* has value TRUE if at least one of the subject specifications has value TRUE
* otherwise has value FALSE.

A policy or policy-set that has no target explicitly specified is treated as having a target that evaluates unconditionally to TRUE.
The target has an id attribute used for syncrhonisation purposes within the personal zone.

h2. Decision

The decision is defined in section B.10 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification.
If determined, the result of a rule or policy or policy set is a decision, either "not applicable" or any one of the effects "permit", "prompt-blanket", "prompt- session", "prompt-oneshot" or "deny". The effects are defined in [[Spec_-_Access_Control_Policy#Effect|Effect]].
The result of a rule or policy or policy set may be undetermined under conditions specified for each below.

h2. Rule

The rule element comes from section B.11 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification. It consists of a [[Spec_-_Access_Control_Policy#Condition|condition]] and an [[Spec_-_Access_Control_Policy#Effect|effect]].
A rule has an id used for syncrhonisation purposes within the personal zone.
The result of a rule (see [[Spec_-_Access_Control_Policy#Decision|decision]]) is determined if and only if its condition has a determined value.

h2. Condition

The condition of a rule (section B.12 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification) specifies extra criteria that need to be matched before the rule becomes applicable.
The condition consists of one or more attribute matches, combined with AND and OR operators into an arbitrarily nested tree.
The AND operator is evaluated as follows:
* is determined and has value "no match" if any input is "no match";
* otherwise is undetermined if any input is undetermined;
* otherwise is determined and has value "match".

The OR operator is evaluated as follows:
* is determined and has value "match" if any input is "match";
* otherwise is undetermined if any input is undetermined;
* otherwise is determined and has value "no match".

Policy
------

The policy element comes from section B.13 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification. A policy has a target, and a list of zero or more rules combined using a rule-combining algorithm (see [[Spec_-_Access_Control_Policy#Combining-algorithm|Combining algorithm]] for the combining algorithms). Where a directive attribute query finds more than one applicable directive attribute set, the first one is used.
A policy optionally has a textual description. It has also an id used for syncrhonisation purposes within the personal zone. If an implementation provides a means to provision a security policy fragment to replace an existing one, this id can be used to identify the policy or policy set to replace. No management of ids is mandated, therefore it is recommended that a standardised textual representation of a UUID should be used as the id.
The result of a policy is determined if and only if its combining rule has determined value.

Policy set
----------

The policy set element comes from section B.14 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification.
A policy set is a target with a list of zero or more policies and policy sets combined using a policy-combining algorithm (see [[Spec_-_Access_Control_Policy#Combining-algorithm|Combining algorithm]] for the combining algorithms). Where a directive attribute query finds more than one applicable directive attribute set, the first one is used.
A policy set has an id used for syncrhonisation purposes within the personal zone. If an implementation provides a means to provision a security policy fragment to replace an existing one, this id can be used to identify the policy or policy set to replace. No management of ids is mandated, therefore it is recommended that a standardised textual representation of a UUID should be used as the id.

The result of a policy is determined if and only if its combining rule has determined value.

Policy Document
---------------

As defined in section B.15 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification, where the implementation supports deployment of a fragment of policy to add to the existing security policy framework or to replace a part of it, the policy document is the unit of addition or replacement. A policy document can be either a policy or a policy set.

h2. Signed Policy Document

As defined in section B.16 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification, where the implementation supports deployment of policy fragments as above, the signed policy document is the cryptographically signed unit of deployment. It contains one or more policy documents as well as a single signature.

Matching function
-----------------

As defined in section B.17 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification the matching function used in an attribute match is one of the following:

h3. String equality matching function

True if and only if some string from one input string bag is byte-for-byte equal to some string from the other input string bag. Thus an empty bag is not equal to anything, not even another empty bag. An input of type other than empty bag or string bag is converted to string bag first.

h3. Globbing matching function

True if and only if, for some string in the first input string bag, the entire string matches the glob pattern in some string in the second input string bag. If either input is the empty bag, the result is false. An input of type other than empty bag or string bag is converted to string bag first.

h3. Regular expression matching function

True if and only if, for some string in the first input string bag, some part of the string matches the regular expression pattern in some string in the second input string bag. If either input is the empty bag, the result is false. An input of type other than empty bag or string bag is converted to string bag first.
This uses the definition of regular expressions in ECMAScript 3rd edition7.

h2. Modifier Function

As defined in section B.18 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification the modifier function optionally specified in each attribute in a target or condition is one of the following.

### URI-Scheme modifier function

If the input is a string bag, first it is converted to a URI bag by interpreting each string as a URI. Any string that does not have the form of a URI is removed from the bag.
Each URI in the bag is converted to a string by taking the URI’s scheme component.
Thus the result type is either the empty bag or string bag

### URI-Authority modifier function

If the input is a string bag, first it is converted to a URI bag by interpreting each string as a URI. Any string that does not have the form of a URI is removed from the bag.
Each URI in the bag is converted to a string by taking the URI’s authority component. If the URI does not have an authority component, it is removed from the bag.
Thus the result type is either the empty bag or string bag.

### URI-Scheme-Authority modifier function

If the input is a string bag, first it is converted to a URI bag by interpreting each string as a URI. Any string that does not have the form of a URI is removed from the bag.
Each URI in the bag is converted to a string by taking the URI’s scheme and authority components. If the URI does not have an authority component, it is removed from the bag.
Thus the result type is either the empty bag or string bag.

### URI-Host modifier function

If the input is a string bag, first it is converted to a URI bag by interpreting each string as a URI. Any string that does not have the form of a URI is removed from the bag.
Each URI in the bag is converted to a string by taking the URI’s host component. If the URI does not have an authority component, it is removed from the bag.
Thus the result type is either the empty bag or string bag.

### URI-Path modifier function

If the input is a string bag, first it is converted to a URI bag by interpreting each string as a URI. Any string that does not have the form of a URI is removed from the bag.
Each URI in the bag is converted to a string by taking the URI’s path component. If the URI does not have an authority component, it is removed from the bag.
Thus the result type is either the empty bag or string bag.

Combining algorithm
-------------------

As defined in section B.19 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification there are two types of combining algorithms: policy-combining algorithms and rule-combining algorithms.
The policy-combining algorithm for a policy set determines how child policies and policy sets are combined.
The rule-combining algorithm for a policy determines how child rules are combined.
The algorithms are described in the following subsections. The term child is used to mean the child rules in the policy when applying the policy’s rule- combining algorithm, or the child policies and policy sets in the policy set when applying the policy set’s policy-combining algorithm.

### Deny-overrides combining algorithm

The deny-overrides combining algorithm is usable as a policy-combining algorithm and as a rule-combining algorithm. The overall result of a query is evaluated as follows.
* If any child evaluates to "deny", then the overall result is "deny".
* Otherwise, if any child is undetermined, then the overall result is undetermined.
* Otherwise, if any child evaluates to "prompt-oneshot", then the overall result is "prompt-oneshot".
* Otherwise, if any child evaluates to "prompt-session", then the overall result is "prompt-session".
* Otherwise, if any child evaluates to "prompt-blanket", then the overall result is "prompt-blanket".
* Otherwise, if any child evaluates to "permit", then the overall result is "permit".
* Otherwise, the overall result is "inapplicable".

### Permit-overrides combining algorithm

The permit-overrides combining algorithm is usable as a policy-combining algorithm and as a rule-combining algorithm.The overall result of a query is evaluated as follows.
* If any child evaluates to "permit", then the overall result is "permit"
* Otherwise, if any child is undetermined, then the overall result is undetermined.
* Otherwise, if any child evaluates to "prompt-blanket", then the overall result is "prompt-blanket".
* Otherwise, if any child evaluates to "prompt-session", then the overall result is "prompt-session".
* Otherwise, if any child evaluates to "prompt-oneshot", then the overall result is "prompt-oneshot".
* Otherwise, if any child evaluates to "deny", then the overall result is "deny".
* Otherwise, the overall result is "inapplicable".

### First-applicable rule combining algorithm

The first-applicable rule combining algorithm is usable as a rule-combining algorithm.
The overall result of a query is evaluated by processing the children in written order as follows:
* if the current child is determined and does not evaluate to "inapplicable", the overall result is the result of the current child;
* otherwise, if the current child is undetermined, the overall result is undetermined;
* otherwise, if the current child is determined and has value "inapplicable", continue processing at the next child. If already processing the final child, the overall result is "inapplicable".

### First-matching-target policy combining algorithm

The first-matching-target policy combining algorithm is usable as a policy- combining algorithm.
The overall result of a query is evaluated by processing the children in written order as follows:
* if the current child has a target that matches the overall result is the result of the current child;
* otherwise, continue processing at the next child. If already processing the final child, the overall result is "inapplicable".

Effect
------

As defined in section B.20 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification the effect of a rule is one of the following:

h3. Permit

This effect allows requested access without user interaction.

h3. Deny

This effect denies requested access without user interaction.

h3. Prompt-X

The prompt-oneshot, prompt-session and prompt-blanket effects allow requested access after explicit confirmation by the user. The implementation MUST prompt the user before allowing access.
The implementation MUST only provide the user the option to grant permission up to the maximum allowed by the effect, ie:
* prompt-oneshot: "deny always", "deny this time", "allow this time";
* prompt-session: prompt-oneshot options plus "deny for this session", "allow for this session";
* prompt-blanket: prompt-session options plus "allow always".

The implementation MUST provide a means to respond with any available option that is applicable in the context in which the prompt is displayed.
Any default action MUST be at least as restrictive as "deny this time".
If the user has the option of deferring a response indefinitely and the user does not respond explicitly, the requested access MUST NOT be allowed.
For a Widget, a session lasts while the application is still running and the terminal has not been switched off or placed in standby mode.
For a Website, another visit to the same page in the same Browser tab or window is part of the same session.

h2. Query

As defined in section B.21 of [[Spec_-_Access_Control_Policy#BONDIA38S|BONDIA&S]] specification a query represents a specific instance of a security policy being evaluated in order to make an access control decision relating to an attempted operation by a Web Application.
A query is characterised by the collection of subject attributes associated with the Web Application instance, the collection of resource attributes associated with rhe attempted operation, and the collection of environment attributes associated with the circumstances of the attempt. The determinedness of each of these attributes is in accordance with the execution phase of the attempt.
A query is evaluated against a policy-set, resulting in a decision in accordance with the evaluation rules defined in this specification.

Core features
-------------

The following table contains some core features referring to widget lifecycle, WRT, network access and policy control functionalities. These features are not associated to APIs and correspond to action performed or controlled by the Widget Manager and the Widget Runtime. It’s not required to declare these features inside any widget configuration document.

  -------------------------------------------- -----------------------------------------------------------------------------------------------------------------------------
  **Feature**                                  **Meaning**
  http://webinos.org/core/widget/install       Identifies the widget installation process
  http://webinos.org/core/widget/instantiate   Identifies the widget instantiation
  http://webinos.org/core/widget/update        Identifies the widget update process
  http://webinos.org/core/widget/uninstall     Identifies the widget removal
  http://webinos.org/core/wrt/update           Identifies the widget update process
  http://webinos.org/core/network-access       Identifies network IO operation operated by widgets. Use a param (_uri_) to identify the remote resource accessed
  http://webinos.org/core/policy-management    Identifies operations related to policy files management
  -------------------------------------------- -----------------------------------------------------------------------------------------------------------------------------

Formal Specification
--------------------

Below are depicted three use cases to show the workflow for:

1.  requests come from an applications inside the device
2.  requests come from outside the Device
3.  requests come from outside the Device, and no Personal Hub is reachable (or it is not contacted for resource usage optimization)

### Distributed architecture, Case 1: requests come from an application inside the device

![](distributed_architecture_1.png)

### Flow description

0. PZP update policies and make them available to the PDP
1. The access requestor sends an access request to the PZP
2. The PZP sends the request for access to the decision wrapper
3. The decision wrapper forwards the request towards the access manager, together with the possible relevant
data handling policies attached to the requested resources

_XACML engine branch_
{
 4. The access manager forwards the request to the PEP
 5. The PEP forwards the request to the context handler
 6. The context handler constructs an XACML request and sends it to the PDP
 7. The PDP requests any additional attributes from the context handler.
 8. The context handler requests the attributes from a PIP
 9. The PIP asks the data reader for requested attributes
 10. The PIP obtains the requested attributes
 11. The PIP returns the requested attributes to the context handler
 12. The context handler sends the requested attributes to the PDP which evaluates the policy
 13. The PDP returns the authorization decision to the context handler
 14. The context handler translates the response to the native response format of the PEP and returns
 the response to the PEP
 15. The PEP returns the access decision to the access manager
}

_Privacy enhanced branch_
{
 a. The access manager forwards the request and the Data Handling Policies to the DHDF engine
 b. The DHDF engine asks the data reader for evaluation information
 c. The DHDF engine obtains information needed for evaluation
 d. The DFDH engine evaluated DH policies and returns the decision to the access manager
}

16. The access manager combines the XACML access control decision and the DHDF data handling decision,
 then it sends the result to the decision wrapper.
17. The decision wrapper forwards the result to the PZP which enforces it.

### Distributed architecture, Case 2: requests come from outside the Device

![](distributed_architecture_2.png)

### Flow description

0. PAP update policies and make them available to the PDP
1. The remote access requestor sends an access request to the PZH across the overlay network
2. The PZH sends the request for access to the decision wrapper
3. The decision wrapper forwards the request towards the access manager, together with the possible relevant
data handling policies attached to the requested resources

_XACML engine branch_
{
 4. The access manager forwards the request to the PEP
 5. The PEP forwards the request to the context handler
 6. The context handler constructs an XACML request and sends it to the PDP
 7. The PDP requests any additional attributes from the context handler.
 8. The context handler requests the attributes from a PIP
 9. The PIP asks the data reader for requested attributes
 10. The PIP obtains the requested attributes
 11. The PIP returns the requested attributes to the context handler
 12. The context handler sends the requested attributes to the PDP which evaluates the policy
 13. The PDP returns the authorization decision to the context handler
 14. The context handler translates the response to the native response format of the PEP and returns
 the response to the PEP
 15. The PEP returns the access decision to the access manager
}

_Privacy enhanced branch_
{
 a. The access manager forwards the request and the Data Handling Policies to the DHDF engine
 b. The DHDF engine asks the data reader for evaluation information
 c. The DHDF engine obtains information needed for evaluation
 d. The DFDH engine evaluated DH policies and returns the decision to the access manager
}

16. The access manager combines the XACML access control decision and the DHDF data handling decision,
 then it sends the result to the decision wrapper.
17. The decision wrapper forwards the result to the PZH
18. The PZH forwards the result to the PZP which enforces it.

### Distributed architecture, Case 3: requests come from outside the Device, and no Personal Hub is reachable (or it is not contacted for resource usage optimization)

![](distributed_architecture_3.png)

### Flow description

0. PZP update policies and make them available to the PDP
1. The remote access requestor sends an access request to the PZP across the overlay network
2. The PZP sends the request for access to the decision wrapper
3. The decision wrapper forwards the request towards the access manager, together with the possible relevant
data handling policies attached to the requested resources

_XACML engine branch_
{
 4. The access manager forwards the request to the PEP
 5. The PEP forwards the request to the context handler
 6. The context handler constructs an XACML request and sends it to the PDP
 7. The PDP requests any additional attributes from the context handler.
 8. The context handler requests the attributes from a PIP
 9. The PIP asks the data reader for requested attributes
 10. The PIP obtains the requested attributes
 11. The PIP returns the requested attributes to the context handler
 12. The context handler sends the requested attributes to the PDP which evaluates the policy
 13. The PDP returns the authorization decision to the context handler
 14. The context handler translates the response to the native response format of the PEP and returns
 the response to the PEP
 15. The PEP returns the access decision to the access manager
}

_Privacy enhanced branch_
{
 a. The access manager forwards the request and the Data Handling Policies to the DHDF engine
 b. The DHDF engine asks the data reader for evaluation information
 c. The DHDF engine obtains information needed for evaluation
 d. The DFDH engine evaluated DH policies and returns the decision to the access manager
}

16. The access manager combines the XACML access control decision and the DHDF data handling decision,
 then it sends the result to the decision wrapper.
17. The decision wrapper forwards the result to the PZP which enforces it.

References
----------

### BONDIA&S

"BONDI’s Architecture and Security Appendices":http://bondi.omtp.org/1.11/security/BONDI_Architecture_and_Security_Appendices_v1.1.pdf, January 2010

### DAPWG

"Device APIs and Policy Working Group":http://www.w3.org/2009/dap/

### RFC3986

"Uniform Resource Identifier (URI): Generic Syntax":http://www.ietf.org/rfc/rfc3986.txt, January 2005

### WACDS

"WAC Device Specifications":http://specs.wacapps.net/2.0/jun2011/index.html, June 2011

### WACXMLSP

"WAC: XML definition of Security Policy (RelaxNG)":http://specs.wacapps.net/2.0/jun2011/core/wacxml.rnc

