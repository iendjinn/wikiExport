Spec - Security
===============

Conceptual Architecture
-----------------------

In Webinos the concept of security is extended in two directions: resources access control and privacy protection.

As reported in the preceding sections one of the most widely used and flexible solutions is represented by XACML ([[Spec_-_Security#OASISXACML|OASISXACML]]). The XACML specification defines an XML-based language and an architecture for the expression and evaluation of access control policies but doesn’t provide neither privacy protection nor the specification and evaluation of credential restrictions in the policies.
With the PrimeLife extension ([[Spec_-_Security#PRIMELIFE|PRIMELIFE]]) the privacy requirements can be fulfilled: the user has control of his personal data and can negotiate its disclosure with the access control system.

### XACML architecture (Data flow)

XACML (eXtensible Access Control Markup Language) is an OASIS standard ([[Spec_-_Security#OASISXACML|OASISXACML]]) for access control systems that defines a language for the description of XML access control policies and an architecture to enforce access control decisions.

The XACML architecture depicted in the figure is composed of the following elements:

_**Access Requestor**_: the entity which requires the capability.

_**Policy Enforcement Point (PEP)**_: the entity that performs access control, by making decision requests and enforcing authorization decisions. It also try to execute the Obligations and doesn’t grant access if is unable to complete these actions.

_**Obligations**_: operations specified in a policy that should be performed by the PEP in conjunction with the enforcement of an authorization decision. These operations must be carried out before or after an access is granted.

_**Policy Decision Point (PDP)**_: the main decision point for the access requests. It collects all the necessary information from other actors and concludes an authorization decision.

_**Context Handler**_: the entity which sends a policy evaluation request to the PDP and manage context-based information.

_**Policy Information Point (PIP)**_: the entity that acts as a source of attribute values that are retrieved from several internal or external parties like resources, subjects, environment and so on.

_**Policy Administration Point (PAP)**_: the repository for the policies, it manages policies and provides them to the Policy Decision Point.

_**Resources / Subjects / Environment**_: parties that provide attributes to the PIP.

{{graphviz(
digraph G {
"Access Requestor"[shape=box]
node [shape=box, fillcolor=lightgray, style="filled, rounded"]
{rank = same; "Access Requestor"; "PEP"; "Obligations"}
{rank = same; "PDP"; "Context Handler"; "PIP"}
{rank = same; "Resources"; "Subjects"; "Environment"}
{rank = same; "PAP"}

"Access Requestor" -> "PEP" [label="2"]
"PEP" -> "Obligations" [label="13"]
"PEP" -> "Context Handler" [label="3, 12", dir=both]
"PDP" -> "Context Handler" [label="4, 5, 10, 11", dir=both]
"Context Handler" -> "PIP" [label="6, 8", dir=both]
"Resources" -> "Context Handler" [label="9"]
"PIP" -> "Resources" [label="7a"]
"PIP" -> "Subjects" [label="7b"]
"PIP" -> "Environment" [label="7c"]
"PDP" -> "PAP" [label="1", dir=both]
}
</div>

In a chronological order the data flow sequence is:

# Policies and policy sets are defined in the PAP and made available to the PDP.
# The Access Requestor sends a request to the PEP for the access to the specified resource.
# The PEP translate the request in native format and sends it to the XACML Context Handler. This may include attributes of the subjects, resources, actions, and environment.
# The Context Handler creates an XACML request context and sends a policy evaluation request to the PDP.
# The PDP, in order to evaluate the policies, queries the Context Handler for attributes of the subject, resource, action, and environment.
# The Context Handler obtains the attributes either from the request context created in step 4, or from the PIP.
# The PIP collects attributes about subject, resource and environment.
# The PIP returns the requested attributes to the Context Handler.
# Optionally, the Context Handler includes the resource in the context.
# The Context Handler returns to the PDP the requested attributes.
# The PDP sends the response context (including the authorization decision) to the Context Handler.
# The Context Handler sends to the PEP the response context in native response format.
# The PEP tries to execute obligations.


h3. XACML extended with PrimeLife for webinos (Data flow)

The architecture chosen to achieve the goals on security and privacy outlined by webinos, is an XACML distributed architecture integrated with the PrimeLife extension.
PrimeLife is a research project on privacy and identity management, funded by the European Commission from 2008 to 2011 ([[Spec_-_Security#PRIMELIFE|PRIMELIFE]]). The project proposes an extension to the standard XACML architecture allowing among other things the support of privacy data handling policies on systems with a resource access control based on XACML.

The main motivations behind the choice of the PrimeLife extension, other than the support of data-handling privacy policies are:
* Introduction of negotiation in the evaluation process: negotiation allows an incremental evaluation of access control policies and reduces the disclosure of personal data.
* Support for credential-based restrictions (digital credential and certified attributes)
* Legislation support (EU privacy directives)
* PrimeLife is an open-source European Project

The complete architecture, depicted below, contains new components that are PZH and PZP defined in the high level webinos architecture, Decision Wrapper, Access Manager, DHDF, Data Reader and Request Context derived from the PrimeLife extension and the PDPC (PDPCache) generally included in XACML’s PDP component. Follows the description of these components:

_**Personal Zone Proxy (PZP)**_: defined in the preceding sections, in this context can act in four ways
* enforces authorization decisions at device level
* synchronizes request context data with other devices
* synchronizes PDP policies with other devices
* verifies credentials towards the request context

_**Personal Zone Hub (PZH)**_: defined in the preceding sections, in this context can act in three ways:
* as a data synchronizer towards the request context (via PZP)
* as a policy synchronizer towards the PDP / PDPC (via PZP)
* as a credential system (responsible for credential verification) towards the request context (via PZP)

_**Decision Wrapper**_: responsible for driving the access control policy evaluation and enforcement.

_**Access Manager**_: the entity in charge of taking the final decision by combining the XACML access.
control and the DHDF data.

_**DHDF Engine**_: Data Handling Decision Function engine provides privacy and data handling functionalities.
It does not implement a complete privacy-aware access control system, but rather it is responsible for
the management and evaluation of data handling policies only.

_**Data Reader**_: responsible for abstracting the communication with the Request Context.

_**Request Context**_: responsible for managing all contextual information; it stores all the data and
credentials released by a user in a given session.

_**PDPC**_: the PDP cache, stores PDP decisions that could be share among personal devices.

{{graphviz(
digraph G {
"RemotenAccessnRequestor"[shape=box]
"Access Requestor"[shape=box]
"CredentialnSystem"[shape=box]
"Overlay Network"[shape=ellipse]
"Webinos CloudnPDPC - PIP - PAP"[shape=ellipse]
node [shape=box, fillcolor=lightgray, style="filled, rounded"]
{rank = same; "Access Requestor"; "Decision Wrapper"}
{rank = same; "DHDFnEngine"; "Access Manager"}
{rank = same; "PEP"; "Obligations"}
{rank = same; "Context Handler"; "PDP"; "PDPC"}
{rank = same; "PIP"; "PZP"; "Webinos CloudnPDPC - PIP - PAP"}
{rank = same; "Data Reader"; "RequestnContext"; "CredentialnSystem"}

"RemotenAccessnRequestor" -> "Overlay Network" -> "PZH/PZP" -> "Decision Wrapper"
"Access Requestor" -> "Decision Wrapper"
"Decision Wrapper" -> "Access Manager"
"DHDFnEngine" -> "Access Manager" [dir=back]
"Access Manager" -> "PEP" -> "Obligations"

"PEP" -> "Context Handler"
"PIP" -> "Context Handler" [dir=back]
"Context Handler" -> "PDP" [dir=both]
"PDP" -> "PDPC"
"PDP" -> "PAP" [dir=both]
"PDPC" -> "PZP" [dir=both]
"PAP" -> "PZP" [dir=both]
"PIP" -> "PZP" -> "Webinos CloudnPDPC - PIP - PAP" [dir=both]
"PIP" -> "Data Reader"
"DHDFnEngine" -> "Data Reader"
"Data Reader" -> "RequestnContext"
"RequestnContext" -> "CredentialnSystem" [dir=back]
}

</div>
The data flow sequence is exposed by the three scenarios presented in the "Formal Specification" paragraph.
Although Obligations are included in the architecture they will be handled in the phase 2.

More aspects on security and privacy will be pointed out in the 3.5 deliverable ([[Spec_-_Security#D035|D035]])

h2. Technical Use Cases

Here are depicted and briefly presented use-cases particularly relevant for policy sub-task.

h3. WOS-UC-TA8-002: Interpreting policies and taking access control decisions

**Normal Flow**

**_Pre-Condition_**
The User has a tablet PC running webinos.
The User has a photo collection on his tablet PC which he would like to share with other people.
The webinos platform has a set of policies installed. These are not contradictory- a decision can always be taken based on their content.

**_Flow_**
1. The User has installed a new photo-sharing Application.
2. The photo-sharing Application automatically tries to upload his photos to a shared repository.
3. Accessing photos stored on the webinos Device - his tablet pc - results in an access-control request to the webinos platform.
4. webinos takes the event (Application X accessing File F) and checks against the set of policies (PS) installed.
5. The policies allow this action, and the photo-sharing app resumes uploading photos.

**_Post-Condition_**
The correct access control decision is taken with respect to all policies.

**Alternate Flow (optional)**

**_Pre-Condition_**
Same as normal flow.

**_Post-Condition_**
5. The policies do not allow this action and the Application is not able to upload any files.
6. The Application fails gracefully, informing the User of why it is unable to complete the request.
7. The access control decision is logged.

**Alternate Flow (optional)**
**_Pre-Condition_**
Same as normal flow.

**_Post-Condition_**
5. The policies require an extra condition before allowing this action: in this case, requesting User input to confirm that this behaviour is permitted.
6. webinos prompts the User to confirm that access to photos is allowed.
7. The User agrees.
8. The photo-sharing Application resumes uploading photos.

### Sequence diagram analysis: WOS-UC-TA8-002 - Interpreting policies and taking access control decisions

<div class="uml">

title usecase WOS-UV-TA8-002

actor "User" as usr

participant "photo-sharingnapplication" as app
participant "PEP" as pep
participant "PDP" as pdp
participant "sharednrepository" as rep

autonumber
note over usr
 this entity includes
 both the real user and
 the webinos front-end
end note

app -> pep : photos upload attempt
pep -> pdp : policies check

alt normal flow
 note over pep, pdp
 policies allow photo upload
 end note
 pdp -> pep : operation granted
 pep -> app : action allowed
 app -> rep : photos upload
else alternate flow
 autonumber 3
 note over pep, pdp
 policies do not allow photo upload
 end note
 pdp -> pep : operation denied
 pep -> app : action not allowed
 app -> usr : upload aborted
 note over usr, app
 the access control
 decision is logged
 end note
else alternate flow
 autonumber 3
 note over pep, pdp
 policies require user confirm
 before allowing photo upload
 end note
 pdp -> pep : confirm requested
 pep -> usr : ask for confirm
 usr -> pep : operation granted
 pep -> app : action allowed
 app -> rep : photos upload
end

</div>
### WOS-UC-TA8-003: Enforcing multiple policies on multiple devices

**Normal Flow**
**_Flow_**
1. The User has a Mobile phone and an in-car entertainment System.
2. The User decides that he does not want to alert local networks to his presence.
3. He uses webinos to specify that his Devices should remain hidden and not discoverable. He does this on his Mobile phone.

**_Post-Condition_**
Any webinos Device used by the User subsequently will not be discoverable by a remote network. This includes his car whenever he is using it.

**Alternate Flow**
**_Pre-Condition_**
A User has both personal and work photos on his webinos Device.

**_Flow_**
1. The User uses a Mobile phone provided by his company, a professional photography business.
2. He has configured it to allow him to share personal information with certain social networking Applications.
3. One of the Applications encourages the sharing of personal photos.
4. He does not see a problem with sharing the photos on his Device, and proceeds, allowing the potential upload of all photos on his Device.
5. However, the company policy protects all the photos owned by the company, many of which he has inadvertently given permission to. These are forbidden from being used by non-trusted Applications.
6. The webinos policy engine interprets the User’s policy and the company policy - knowing that the company, as the phone’s owner, takes precedence - and denies access to the relevant photos.

**_Post-Condition_**
The User can only share his own photos with his social network Application, not any of the company’s copyrighted photos.

### Sequence diagram analysis: WOS-UC-TA8-003 - Enforcing multiple policies on multiple devices (normal flow)

<div class="uml">

title usecase WOS-UV-TA8-003nnormal flow

actor "User" as usr
participant "mobile privacyndashboard" as mobile_pd
participant "mobile discoverynservice" as mobile_sd
participant "mobilenPEP" as mobile_pep
participant "mobilenPDP" as mobile_pdp
participant "cloudnPDPC" as cloud_pdpc
participant "in-carnPDP" as car_pdp
participant "in-carnPEP" as car_pep
participant "in-car discoverynservice" as car_sd

autonumber

usr -> mobile_pd : set hidden mode
mobile_pd -> mobile_pep : privacy setting modification attempt
mobile_pep -> mobile_pdp : policies check
mobile_pdp -> mobile_pep : operation granted
mobile_pep -> mobile_pd : action allowed
mobile_pd -> mobile_pdp : new privacy settings
note over mobile_pdp, cloud_pdpc
 through mobile PDPC
 and mobile PZP
end note
mobile_pdp -> cloud_pdpc : policy update
note over cloud_pdpc, car_pdp
 through in-car PZP
 and in-car PDPC
end note
cloud_pdpc -> car_pdp : policy update

 mobile discovery 

note over mobile_pdp
 assumption: a hello message arrives to the discovery service
 alternative assumption: the PEP may recognize a hello message and filter
 it accordingly to the policy, avoiding to send it to the discovery service
end note

note over mobile_sd
 a nearby device tries
 to sense the mobile
end note

mobile_sd -> mobile_pep : discovery attempt
mobile_pep -> mobile_pdp : policies check
mobile_pdp -> mobile_pep : operation denied
mobile_pep -> mobile_sd : action not allowed

 in-car system discovery

note over car_sd
 a nearby device tries to
 sense the in-car system
end note

car_sd -> car_pep : discovery attempt
car_pep -> car_pdp : policies check
car_pdp -> car_pep : operation denied
car_pep -> car_sd : action not allowed

</div>
### WOS-UC-TA8-007: Policy authoring tools

**Normal Flow**
**_Pre-Condition_**
The Developer’s company has ownership of company Devices and is able to set policies which cannot be overridden by the End Users.

**_Flow_**
1. The Developer knows that webinos policies are written in a standard language and he downloads a webinos policy editing tools to help him create a suitable policy for his requirements.
2. He uses the tool to select the class of assets which she is concerned about - all data owned by the company.
3. He then sets a mandatory policy that this data is not allowed to be shared with any Application not signed by the company. All access to the data should also be logged.
4. He also selects a default policy for personal data, stating that it should not be shared with Applications by default.
5. The Developer modifies various other settings until he is happy with the policy.
6. The tool provides several examples of how his policy would be applied, and what it allows and denies access to.
7. He then tests his policy against several example Device configurations that the tool supports. This shows him that Devices using his policy would still be able to run, but would not be able to access company data.
8. He saves the policy and signs it to mark it as a trusted company policy.

**_Post-Condition_**
The company policy can be applied to all Devices the company owns and will control webinos Applications in the ways defined by the Developer.

**Alternate Flow (optional)**
**_Flow_**
7. The Developer tests the policy and realizes that it prevents Applications from accessing any data on the Devices. This is shown to him using the policy tool.
8. He realizes his mistake and modifies the policy suitably.

### Sequence diagram analysis: WOS-UC-TA8-007 - Policy authoring tools

<div class="uml">

actor "developer" as dev
participant "policy tool" as tool
participant "PEP" as pep
participant "PDP" as pdp

autonumber

note over tool
 assumption: policies are tested into the
 device and not into a policy tool environment
end note

dev -> tool : set up company policies
tool -> pep : policies modification attempt

pep -> pdp : policies check
pdp -> pep : operation granted
pep -> tool : action allowed
tool -> pdp : new policies set up

 test 

dev -> tool : company data sharing test
tool -> pep : share company data
pep -> pdp : policies check
pdp -> pep : operation denied
pep -> tool : action not allowed
tool -> dev : company data sharing not allowed

dev -> tool : personal data sharing test
tool -> pep : share personal data
pep -> pdp : policies check

alt normal flow
 pdp -> pep : operation granted
 pep -> tool : action allowed
 tool -> dev : personal data sharing allowed
 note over dev, tool
 Test succesfull. The developer saves
 the policy and signs it to mark it
 as a trusted company policy
 end note
else alternate flow
 autonumber 16
 pdp -> pep : operation denied
 pep -> tool : action not allowed
 tool -> dev : personal data sharing not allowed
 note over dev, tool
 Test unsuccesfull. The developer
 modifies policies
 end note
end

</div>
Here some further use-cases whose aim is to highlight policy interactions.

### Cross-Device Policy Synchronisation

_**Installing an app (’A’) on device ’D’, granting it permissions, and then wanting to allow it to use device ’E’:**_

* Assume device ‘D’ and ‘E’ are used only by the user Justin.
 * Justin "installs" ‘A’ on ‘D’.
 * At end of install process, after granting the application some permissions, Justin is prompted "This application can be used on multiple devices. Install on [list of user devices and tick box]"
 * Justin selects that the application should be installed on device ‘E’ as well.
 * Prompt: "Give application permission to access the same resources? / Customise permissions / Ask me later?"
 * Justin clicks "give same resources"
 * Webinos runtime creates a message to device ‘E’ containing instructions for doing this.
 o Name of application, permissions granted on this device
 o Justin’s credentials/signature
 * Message queued to be sent on the overlay network to the other device, using a secure transport session. This may happen immediately if possible (e.g. if device ‘D’ is a home server) or may wait for a proximity event, or may be queued on a cloud service waiting for the user to interact with device ‘D’ in the future.

_**Using device ’D’ to remove permission for app ’A’ to access resource ’R’ on all devices (Device ’D’ and ’E’):**_

* Peter has been using app ‘A’ and decides he doesn’t trust it after being told by a friend that it sends data to advertisers.
 * He is using device ‘D’, as this is his main device
 * He navigates to the policy management area (or maybe he right-clicks on the application icon) and selects "remove".
 * He is asked whether he wants it to be removed across all of his devices (a list of his local devices might be selected) and he clicks on all of them.
 * Webinos runtime generates a signed update message to each device in his cloud, including device ‘E’, in a secure manner:
 o "Remove app", app name
 o user credentials, device credentials
 * These are sent when the device is able to connect to other devices and when these devices are capable of authenticating themselves
 * Depending on the device security policies, the deletion may happen automatically, or the app might be isolated and require local permission to delete

_**Using device ’D’ to authorise app ’A’ to access resource ’P’ on device ’E’ (E and D owned by the same user):**_
_**Using device ’D’ to authorise app ’A’ to access resource ’P’ on device ’E’ (E and D owned by different users):**_

* Helen is using app ‘A’ and wants to use it to access her friend Gloria’s photos on device ‘D’.
 * She selects to discover other devices, and finds Gloria’s device ‘D’
 * She requests access to photos on ‘D’.
 * Gloria’s device prompts Gloria to allow this and presents Alice’s device details, as well as the history of communication with this device.
 * Gloria approves the communication
 * Gloria’s runtime adds a temporary permission for the photo app (resource ‘P’) on Gloria’s phone

_**Updating labels on stored user data - marking some as ’private’ on device ’D’ and having the same data on device ’E’ automatically tagged:**_

* Gloria decides to make sure her personal data is being protected appropriately
 * She looks at her webinos device to see what data about her is known
 * Some data is marked as "private" and other data is not.
 * She notes that her "place of work" is listed but not marked as private
 * She tags this data as "private" and therefore all policies apply to it that apply to other private data.
 * She tells webinos to update this setting on all her devices
 * Webinos queues a signed policy update request for device ‘E’:
 o Update policy, data item, new XACML
 o User credentials, device credentials

_**Registering device ’F’ as being a trusted device with respect to device ’D’ and device ’E’:**_

* Anna has just bought a new tablet PC (‘F’), and would like it to automatically synchronise with other devices
 * She uses it to discover her mobile phone (‘D’), a webinos device.
 * On discovery, she selects the mobile phone symbol and chooses to join the "local webinos device cloud"
 * Untrusted message from tablet to phone:
 o "device join", device ID
 * This prompts her mobile phone to authenticate her
 * She enters her credentials into the phone
 * The phone adds this device to a "known" and "personal devices" set
 * The tablet PC downloads the relevant set of policies (as well as profile info - out of scope ) from the mobile phone and applies them. This includes the identity of other devices in the cloud.

Policy Format
-------------

Policies are expressed in the simplified XACML format defined in "BONDI’s Architecture & Security Requirements (Appendices) v1.1" ([[Spec_-_Security#BONDIAxxS|BONDIA&S]]) following the grammar provided by WAC ([[Spec_-_Security#WACXMLSP|WACXMLSP]]). This format has been used as a basis in different specifications as W3C DAP ([[Spec_-_Security#DAPWG|DAPWG]]) and WAC ([[Spec_-_Security#WACDS|WACDS]]).
In the following sections are described only the updates to the BONDI policy format:
* Some new attributes enhance the subject’s information to fit webinos needs on distribution of policies between devices and cross device interaction.
* Two new attributes enhance the resource’s information to identify services and the extensions that could be declared in an application manifest.

For further details and all points not covered here refer to ([[Spec_-_Security#BONDIAxxS|BONDIA&S]]).

h2. IDs in policies

All IDs used in policies to match "subjects" and services (which are "resources") are URIs coming from the data described below.

Whenever an entity (user, device, application or service) is registered for the first time in a PZP/PZH, a record with some basic identity information is stored locally to the PZP/PZH.
These trusting records- mainly used to convert a generic ID in a handy URI (loosely coupling them) and to locate the trusted entity’s certificates - should contain the following information:

-   ID: according to the entity could be one of the following
    -   User ID eg. webinos/facebbok/google ID
    -   Device ID eg. MAC address, IMEI, HD serial number
    -   Service/application ID eg. URI, URL
-   Friendly Name: name that could be prompted in a dialog
-   URI: generated on the fly the first time and the used to address the entity.
-   Certificates: list of URL/paths to certificates
-   Extensions: [For the phase2] for custom metadata and validation rules, e.g. checking IP addresses, MAC addresses, attestation data.

To synchronize these information PZPs/PZH can use JSON array. No format is defined to store locally these data.

**JSON definition of a single trusting record:**
<pre><code class="javascript">
{
 "id": "...",
 "friendly-name": "...",
 "uri": "...",
 "certificates": [
 …
 ],
 "extensions": {
 …
 }
}
</code></pre>

Policy Subject
--------------

Given a policy, the policy subject define the entity to which the policy will be applied. A policy may be applied to many subjects that are called target of the policy.

The subject form used is of the following type:

"User U can access Feature F of Device D through the application A running in a Device X"

"Device D" is also identified as target device whilst the "Device X" is identified as requestor device.

There are four basic information points in this subject:

1.  WHO want to access a resource: could be an user (generic or not) or a group
2.  WHERE the access requestor is: make possible to differentiate a local access (INTRA-DEVICE) from a remote access (INTRA-PZ or EXTRA-PZ)
3.  WHERE the resource is: allow to use the same policy file for many devices
4.  WHICH application is used: could be used to differentiate behaviour for application of different authors, distributors etc..

These information may be all present or not and in this case will be used the default values (referring to the INTRA-DEVICE scenario)

Pros:

* The user is represented explicitly.
 * Policies can be copied to multiple devices without changes.
 * Can represent complex scenarios.

Cons:

* Could be not so intuitive, but the user will manage policies by simple tools
 * The policy is user-dependent, but default policies could be defined using some "generic users" (see User Info paragraph ([[Spec_-_Security#User-Info|User-Info]])).

h2. Subject Attributes

The subject attributes are divided in three groups:

# Widget/Website Identity
# Devices Info
# User Info

the first group comes from the "B.4 Subject Attributes" section of ([[Spec_-_Security#BONDIAxxS|BONDIA&S]]) and defines the properties used to identify the applications (widgets/websites).

The only changes to this set are related to the attributes "id", "uri" and "uri-top" that other than the values defined in ([[Spec_-_Security#BONDIAxxS|BONDIA&S]]) could contain one of the following URIs:

* http://www.webinos.org/subject/info/id/trusted
* http://www.webinos.org/subject/info/id/not-trusted

The other two groups regarding to the devices and users information are presented below

h3. Devices Info

The Devices Info attributes express which device will apply the policies (the target) and which will try to access the features of the first one (the requestor).
If the target-id is absent then the target device will be the "current device" and in a similar way if the requestor-id is absent the requestor will be the "current device".
The "current device" is the device that enforces the policy.

|**Attribute**|**Type**|**Value**|
|target-id|URI|ID of the device where the policy will be enforced. An ID could be a generic device URI (see list below) or a PZP generated one|
|target-domain|URI|Domain of the target device. Refer to the domain URIs listed below|
|requestor-id|URI|ID of the device requesting resources. An ID could be a generic device URI (see list below) or a PZP generated one|
|requestor-domain|URI|Domain of the requestor device. Refer to the domain URIs listed below|
|webinos-enabled|Boolean|True if requestor device is webinos enabled. If this attribute is not specified doesn’t matter if the device is webinos enabled or not|

_**Generic device URIs:**_
* http://www.webinos.org/subject/device-info/id/device (default)
* http://www.webinos.org/subject/device-info/id/pz-device (trusted device)
* http://www.webinos.org/subject/device-info/id/pz-shared-device (trusted device)
* http://www.webinos.org/subject/info/id/trusted (any trusted device)
* http://www.webinos.org/subject/info/id/not-trusted
* http://www.webinos.org/subject/info/id/any

_**Domain URIs:**_
* http://www.webinos.org/subject/device-info/domain/automotive
* http://www.webinos.org/subject/device-info/domain/desktop
* http://www.webinos.org/subject/device-info/domain/home-media
* http://www.webinos.org/subject/device-info/domain/mobile

http://www.webinos.org/subject/device-info/domain/ is the default domain URI value and represents all domains.


h3. User Info

The User Info attributes allow to define the user to which a policy is referred. If the user-id is absent then the subject refers to any user.

|**Attribute**|**Type**|**Value**|
|user-id|URI|ID of the user to which the policy will be applied. An ID could be a generic user URI (see list below) or a PZP generated one|
|user-key-cn|String|The common name of the certificate for the user signature|
|user-key-fingerprint|String|The fingerprint of the certificate for the user signature|
|user-key-root-cn|String|The common name of the root certificate for the user signature|
|user-key-root-fingerprint|String|The fingerprint of the root certificate for the user signature|

_**Generic user URIs:**_
* http://www.webinos.org/subject/user-info/id/pz-owner (trusted user)
* http://www.webinos.org/subject/user-info/id/pz-member (trusted user)
* http://www.webinos.org/subject/user-info/id/trusted-by-pz-owner
* http://www.webinos.org/subject/user-info/id/trusted-by-pz-member
* http://www.webinos.org/subject/info/id/trusted (user trusted by PZ-owner and any PZ-member)
* http://www.webinos.org/subject/info/id/not-trusted
* http://www.webinos.org/subject/user-info/id/anonymous

h2. Resource Attributes

In order to control the utilization of third party developers extensions, as defined in the [[Extensions background]] section of this document, the following attribute is introduced to complete the list defined in "B.5 Resource Attributes" section of ([[Spec_-_Security#BONDIAxxS|BONDIA&S]]):

  --------------- ---------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  **Attribute**   **Type**   **Value**
  service         URI        URI that identifies the service
  app-extension   URI        URI that identifies the extension. If for the extension is not defined an URI, this will be composed by the application URI followed by the name of the extension (using percent-encoding for special characters [[Spec_-_Security#RFC3986
  --------------- ---------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The attributes "service" and "app-extension" could contain one of the following URIs:
* http://www.webinos.org/resource/info/id/trusted
* http://www.webinos.org/resource/info/id/not-trusted

Action features
---------------

The representation of all privileged features that are part of WRT and can be enforced by policy manager but are invisible to the developers, is made through the action features listed below that refers to the widget lifecycle and to the WRT and policy control.

-   http://www.webinos.org/action/widget-install
-   http://www.webinos.org/action/widget-instantiate
-   http://www.webinos.org/action/widget-update
-   http://www.webinos.org/action/widget-uninstall
-   http://www.webinos.org/action/wrt-update
-   http://www.webinos.org/action/wrt-monitoring
-   http://www.webinos.org/action/data-logging
-   http://www.webinos.org/action/network-access
-   http://www.webinos.org/action/policy-management

Policy Examples
---------------

Below is presented a group of simple policies that cover different scenarios like widget installation, feature / external services access control, resource sharing, policies outsourcing and management. The examples show policies for single and multiple devices.

In the following the "User U" is the user that can physically control the device and is logged in it.

### User U wants to install Application A and grant it access to APIs J0-J9

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="id" match="(Application A)"/>
 </subject>
 </target>

<rule effect="permit">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://www.webinos.org/action/widget-install"/>

<resource-match attr="api-feature" match="(API J0)"/>
 <resource-match attr="api-feature" match="(API J1)"/>
 …
 <resource-match attr="api-feature" match="(API J9)"/>
 </condition>
 </rule>

<rule effect="deny" />
</policy>
</code></pre>

### User U wants to grant Application A access to APIs J0-J9, but only on device M

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="id" match="(Application A)"/>
 <subject-match attr="target-id" match="(Device M)"/>
 </subject>
 </target>

<rule effect="permit">
 <condition combine="or">
 <resource-match attr="api-feature" match="(API J0)"/>
 <resource-match attr="api-feature" match="(API J1)"/>
 …
 <resource-match attr="api-feature" match="(API J9)"/>
 </condition>
 </rule>

<rule effect="deny" />
</policy>
</code></pre>

### User U wants to grant Application A access to APIs J0-J9, on devices M and N.

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="id" match="(Application A)"/>
 <subject-match attr="target-id" match="{(Device M), (Device N)}"/>
 </subject>
 </target>

<rule effect="permit">
 <condition combine="or">
 <resource-match attr="api-feature" match="(API J0)"/>
 <resource-match attr="api-feature" match="(API J1)"/>
 …
 <resource-match attr="api-feature" match="(API J9)"/>
 </condition>
 </rule>

<rule effect="deny" />
</policy>
</code></pre>

### User U wants to grant Application A access to all extensions defined in its manifest (only on his cars) and to API J0 (on all devices)

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="id" match="(Application A)"/>
 </subject>
 </target>

<rule effect="permit">
 <condition combine="or">
 <condition>
 <subject-match attr="target-domain" match="http://www.webinos.org/subject/device-info/domain/automotive"/>
 <resource-match attr="app-extension" match="*"/>
 </condition>

<resource-match attr="api-feature" match="(API J0)"/>
 </condition>
 </rule>

<rule effect="deny" />
</policy>
</code></pre>

### User U wants to share his photos (P0-P99) with User V.

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="user-id" match="(User V)"/>
 </subject>
 </target>

<rule effect="permit">
 <condition>
 <resource-match attr="device-cap" match="(method to access to photos)"/>
 <resource-match attr="param:(name of the param that identifies a photo)" match="path_to_photos/P(0|[1..9][0..9]?)" func="regexp"/>
 </condition>
 </rule>

<rule effect="deny" />
</policy>
</code></pre>

### Grant Application A to use services provided by Application B, hosted somewhere else (not in the current device).

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="id" match="(Application A)"/>
 </subject>
 </target>

<rule effect="deny">
 <condition>
 <resource-match attr="service" match="(Services exposed by application B)"/>
 <subject-match attr="target-id" match="http://www.webinos.org/subject/device-info/id/device"/>
 </condition>
 </rule>

<rule effect="permit">
 <condition>
 <resource-match attr="service" match="(Services exposed by application B)"/>
 </condition>
 </rule>

<rule effect="deny" />
</policy>
</code></pre>

### Application A wants to use services provided by Application B, also present on the same device M.

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="id" match="(Application A)"/>
 </subject>
 </target>

<rule effect="permit">
 <condition>
 <resource-match attr="device-cap" match="(Services exposed by application B)"/>
 </condition>
 </rule>

<rule effect="deny" />
</policy>
</code></pre>

### User U works for Company MegaCorp who want to have remote access to work data items W0-W99.

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="user-id" match="(MegaCorp)"/>
 </subject>
 </target>

<rule effect="permit">
 <condition>
 <resource-match attr="device-cap" match="(method to access to work data items)"/>
 <resource-match attr="param:(name of the param that identifies a work data item)" match="W(0|[1..9][0..9]?)" func="regexp"/>
 </condition>
 </rule>

<rule effect="deny" />
</policy>
</code></pre>

### User U wants to restrict Application A from using network N.

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="id" match="(Application A)"/>
 </subject>
 </target>

<rule effect="deny">
 <condition>
 <resource-match attr="api-feature" match="http://www.webinos.org/action/network-access"/>
 <environment-match attr="bearer-name" match="(Network N)">
 </condition>
 </rule>

<rule effect="prompt-oneshot" />
</policy>
</code></pre>

### User U wants Application A to work using network N when he is at MegaCorp and wants to use network L when he is at home. [For the phase2]

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="id" match="(Application A)"/>
 </subject>
 </target>

<rule effect="permit">
 <condition combine="or">
 <condition combine="and">
 <resource-match attr="api-feature" match="http://www.webinos.org/action/network-access"/>
 <environment-match attr="bearer-name" match="(Network N)">
 <environment-match attr="[current-checkin-location]" match="(Location MegaCorp)">
 </condition>
 <condition combine="and">
 <resource-match attr="api-feature" match="http://www.webinos.org/action/network-access"/>
 <environment-match attr="bearer-name" match="(Network L)">
 <environment-match attr="[current-checkin-location]" match="(Location Home)">
 </condition>
 </condition>
 </rule>

<rule effect="deny" />
</policy>
</code></pre>

### User U wants third party S to manage his policy settings on his device M

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="user-id" match="(Third party S)"/>
 <subject-match attr="target-id" match="(Device M)"/>
 </subject>
 </target>

<rule effect="permit">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://www.webinos.org/action/policy-manage"/>
 </condition>
 </rule>

<rule effect="deny" />
</policy>
</code></pre>

### User U wants third party S to manage his policy settings on all his (PZ) devices: M, N and O.

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="user-id" match="(Third party S)"/>
 <subject-match attr="target-id" match="http://www.webinos.org/subject/device-info/id/pz-device"/>
 </subject>
 </target>

<rule effect="permit">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://www.webinos.org/action/policy-management"/>
 </condition>
 </rule>

<rule effect="deny" />
</policy>
</code></pre>

### User U is not allowed to install applications on device M.

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="user-id" match="(User U)"/>
 <subject-match attr="target-id" match="(Device M)"/>
 </subject>
 </target>

<rule effect="deny">
 <condition>
 <resource-match attr="api-feature" match="http://www.webinos.org/action/widget-install"/>
 </condition>
 </rule>

<rule effect="prompt-oneshot"/>
</policy>
</code></pre>

### Developer D1 wants to update the required access control policy for application A as part of an upgrade. [For the phase2]

<pre><code class="xml">
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="author-key-fingerprint" match="(Author D1)"/>
 </subject>
 </target>

<rule effect="permit">
 <condition>
 <resource-match attr="api-feature" match="http://www.webinos.org/action/policy-management"/>
 <resource-match attr="param:id" match="(Policy for application A)"/>
 </condition>
 </rule>

<rule effect="deny"/>
</policy>
</code></pre>

### Application A1 wants to access (historic) context information provided by service/sensor S1 on device M. [For the phase2]

<pre><code class="xml">
<!— SIMILAR TO: User U wants to grant Application A access to APIs J0-J9, but only on device M -->
<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="id" match="(Application A1)"/>
 <subject-match attr="target-id" match="(Device M)"/>
 </subject>
 </target>

 <rule effect="permit">
 <condition>
 <resource-match attr="api-feature" match="(API that allows to access (historic) context information provided by services/sensors)"/>
 <resource-match attr="param:(param that identifies services/sensors)" match="(Service/Sensor S1)"/>
 </condition>
 </rule>

 <rule effect="deny" />
</policy>
</code></pre>

h2. Privilege Apps and Services (Access Control)

{{export_include(3.3_Deliverable_Specifications_Privileged_Apps</div>

h2. Formal Specification

Below are depicted three use cases to show the workflow for:

# requests come from an applications inside the device
# requests come from outside the Device
# requests come from outside the Device, and no Personal Hub is reachable (or it is not contacted for resource usage optimization)

h3. Distributed architecture, Case 1: requests come from an application inside the device

{{graphviz(
digraph "Local scenario" {
 subgraph cluster_legend {
 label = "Legend";
 color = black;

 node [shape=box, style="filled, rounded"];
 "Startingnpoint" [fillcolor="#FFAAAA"];
 "Uncertainnnode" [fillcolor=lightyellow];
 }
 subgraph cluster_pzd {
 label = "Personal Zone Device";
 color = "#BBEEFF";
 style = filled;

 subgraph cluster_enhanced {
 label = "Privacy enhanced XACML architecture"
 color = "#99CCFF";
 style = filled;

 // Nodes
 node [shape=box, fillcolor=lightgray, style="filled, rounded"];
 7 [label="DHDFnEngine"];
 8 [label="Access Manager"];

 {rank = same; 7;8}

 // Arcs
 7 -> 8 [label="a,d",dir=both];

 subgraph cluster_xacml_engine {
 label = "XACML engine"
 color = "#7799FF";
 style = filled;

 // Nodes
 node [shape=box, fillcolor=lightgray, style="filled, rounded"];
 9 [label="PEP"];
 10 [label="Obligations"];
 11 [label="Context Handler"];
 12 [label="PDP"];
 14 [label="PIP"];

 {rank = same; 9;10}
 {rank = same; 11;12}

 // Arcs
 9 -> 10 [label="15"];
 9 -> 11 [label="5,14",dir=both];
 11 -> 12 [label="6,7n12,13",dir=both];
 11 -> 14 [label="8,11",dir=both];
 }
 }

 // Nodes
 node [shape=box, fillcolor=lightgray, style="filled, rounded"];
 2 [label="Access Requestor",fillcolor="#FFAAAA"];
 6 [label="Decision Wrapper",fillcolor=lightyellow];
 15 [label="PersonalnZone Proxy"];
 16 [label="Data Reader"];
 17 [label="RequestnContext"];

 {rank = max; 15}

 // Arcs
 2 -> 15 [label="1"];
 6 -> 8 [label="3,17",dir=both];
 8 -> 9 [label="4,16",dir=both];
 14 -> 16 [label="9,10" dir=both];
 7 -> 16 [label="b,c",dir=both,minlen=4];
 16 -> 17 [dir=both];
 15 -> 12 [label="0"];
 6 -> 15 [label="2,18",dir=both,constraint=false];
 17 -> 15 [dir=both];
 }

 subgraph cluster_pzhd {
 label = "Personal ZonenHub Device";
 color = "#BBEEFF";
 style = filled;

 // Nodes
 node [shape=box, fillcolor=lightgray, style="filled, rounded"];
 h15 [label="PersonalnZone Hub"];
 }

 // Arcs
 15 -> h15 [dir=both];
}
</div>

h3. Flow description

0. PZP update policies and make them available to the PDP
1. The access requestor sends an access request to the PZP
2. The PZP sends the request for access to the decision wrapper
3. The decision wrapper forwards the request towards the access manager, together with the possible relevant
data handling policies attached to the requested resources

_XACML engine branch_
{
 4. The access manager forwards the request to the PEP
 5. The PEP forwards the request to the context handler
 6. The context handler constructs an XACML request and sends it to the PDP
 7. The PDP requests any additional attributes from the context handler.
 8. The context handler requests the attributes from a PIP
 9. The PIP asks the data reader for requested attributes
 10. The PIP obtains the requested attributes
 11. The PIP returns the requested attributes to the context handler
 12. The context handler sends the requested attributes to the PDP which evaluates the policy
 13. The PDP returns the authorization decision to the context handler
 14. The context handler translates the response to the native response format of the PEP and returns
 the response to the PEP
 15. The PEP fulfils the obligations
 16. The PEP returns the access decision to the access manager
}

_Privacy enhanced branch_
{
 a. The access manager forwards the request and the Data Handling Policies to the DHDF engine
 b. The DHDF engine asks the data reader for evaluation information
 c. The DHDF engine obtains information needed for evaluation
 d. The DFDH engine evaluated DH policies and returns the decision to the access manager
}

17. The access manager combines the XACML access control decision and the DHDF data handling decision,
 then it sends the result to the decision wrapper.
18. The decision wrapper forwards the result to the PZP which enforces it.


h3. Distributed architecture, Case 2: requests come from outside the Device

{{graphviz(
digraph "Hub remote scenario" {
 subgraph cluster_legend {
 label = "Legend";
 color = black;

 node [shape=box, style="filled, rounded"];
 "Startingnpoint" [fillcolor="#FFAAAA"];
 "Uncertainnnode" [fillcolor=lightyellow];
 }

 // Nodes
 1 [label="RemotenAccessnRequestor", shape=box, fillcolor="#FFAAAA", style="filled"];
 4 [label="Overlay Network",shape=ellipse];

 subgraph cluster_pzd {
 label = "Personal Zone Device";
 color = "#BBEEFF";
 style = filled;

 // Nodes
 node [shape=box, fillcolor=lightgray, style="filled, rounded"];
 15 [label="PersonalnZone Proxy"];

 }

 subgraph cluster_pzhd {
 label = "Personal Zone Hub Device";
 color = "#BBEEFF";
 style = filled;

 subgraph cluster_enhanced {
 label = "Privacy enhanced XACML architecture"
 color = "#99CCFF";
 style = filled;

 // Nodes
 node [shape=box, fillcolor=lightgray, style="filled, rounded"];
 h7 [label="DHDFnEngine"];
 h8 [label="Access Manager"];

 {rank = same; h7;h8}

 // Arcs
 h8 -> h7 [label="a,d",dir=both];

 subgraph cluster_xacml_engine {
 label = "XACML engine"
 color = "#7799FF";
 style = filled;

 // Nodes
 node [shape=box, fillcolor=lightgray, style="filled, rounded"];
 h9 [label="PEP"];
 h10 [label="Obligations"];
 h11 [label="Context Handler"];
 h12 [label="PDP"];
 h13 [label="PDPC"];
 h14 [label="PIP"];
 h19 [label="PAP"];

 {rank = same; h9;h10}
 {rank = same; h11;h12}

 // Arcs
 h9 -> h10 [label="15"];
 h9 -> h11 [label="5,14",dir=both];
 h11 -> h12 [label="6,7n12,13",dir=both];
 h11 -> h14 [label="8,11",dir=both];
 h12 -> h13;
 h12 -> h19 [label="0",dir=back];

 }
 }

 // Nodes
 node [shape=box, fillcolor=lightgray, style="filled, rounded"];
 h6 [label="Decision Wrapper",fillcolor=lightyellow];
 h15 [label="PersonalnZone Hub"];
 h16 [label="Data Reader"];
 h17 [label="RequestnContext"];

 {rank = max; h15}

 // Arcs
 h6 -> h8 [label="3,17",dir=both];
 h8 -> h9 [label="4,16",dir=both];
 h13 -> h15 [dir=both];
 h19 -> h15 [dir=both];
 h14 -> h16 [label="9,10",dir=both];
 h7 -> h16 [label="b,c",dir=both];
 h16 -> h17 [dir=both];
 h17 -> h15 [dir=both];
 h15 -> h6 [label="2,18",dir=both,constraint=false];
 }

 // Arcs
 1 -> 4;
 4 -> h15 [label="1"];
 h15 -> 15 [label="19"];
}
</div>

h3. Flow description

0. PAP update policies and make them available to the PDP
1. The remote access requestor sends an access request to the PZH across the overlay network
2. The PZH sends the request for access to the decision wrapper
3. The decision wrapper forwards the request towards the access manager, together with the possible relevant
data handling policies attached to the requested resources

_XACML engine branch_
{
 4. The access manager forwards the request to the PEP
 5. The PEP forwards the request to the context handler
 6. The context handler constructs an XACML request and sends it to the PDP
 7. The PDP requests any additional attributes from the context handler.
 8. The context handler requests the attributes from a PIP
 9. The PIP asks the data reader for requested attributes
 10. The PIP obtains the requested attributes
 11. The PIP returns the requested attributes to the context handler
 12. The context handler sends the requested attributes to the PDP which evaluates the policy
 13. The PDP returns the authorization decision to the context handler
 14. The context handler translates the response to the native response format of the PEP and returns
 the response to the PEP
 15. The PEP fulfils the obligations
 16. The PEP returns the access decision to the access manager
}

_Privacy enhanced branch_
{
 a. The access manager forwards the request and the Data Handling Policies to the DHDF engine
 b. The DHDF engine asks the data reader for evaluation information
 c. The DHDF engine obtains information needed for evaluation
 d. The DFDH engine evaluated DH policies and returns the decision to the access manager
}

17. The access manager combines the XACML access control decision and the DHDF data handling decision,
 then it sends the result to the decision wrapper.
18. The decision wrapper forwards the result to the PZH
19. The PZH forwards the result to the PZP which enforces it.


h3. Distributed architecture, Case 3: requests come from outside the Device, and no Personal Hub is reachable (or it is not contacted for resource usage optimization)

{{graphviz(
digraph "Proxy remote scenario" {
 subgraph cluster_legend {
 label = "Legend";
 color = black;

 node [shape=box, style="filled, rounded"];
 "Startingnpoint" [fillcolor="#FFAAAA"];
 "Uncertainnnode" [fillcolor=lightyellow];
 }

 // Nodes
 1 [label="RemotenAccessnRequestor", shape=box, fillcolor="#FFAAAA", style="filled"];
 4 [label="Overlay Network",shape=ellipse];

 subgraph cluster_pzd {
 label = "Personal Zone Device";
 color = "#BBEEFF";
 style = filled;

 subgraph cluster_enhanced {
 label = "Privacy enhanced XACML architecture"
 color = "#99CCFF";
 style = filled;

 // Nodes
 node [shape=box, fillcolor=lightgray, style="filled, rounded"];
 7 [label="DHDFnEngine"];
 8 [label="Access Manager"];

 {rank = same; 7;8}

 // Arcs
 8 -> 7 [label="a,d",dir=both];

 subgraph cluster_xacml_engine {
 label = "XACML engine"
 color = "#7799FF";
 style = filled;

 // Nodes
 node [shape=box, fillcolor=lightgray, style="filled, rounded"];
 9 [label="PEP"];
 10 [label="Obligations"];
 11 [label="Context Handler"];
 12 [label="PDP"];
 14 [label="PIP"];

 {rank = same; 9;10}
 {rank = same; 11;12}

 // Arcs
 9 -> 10 [label="15"];
 9 -> 11 [label="5,14",dir=both];
 11 -> 14 [label="8,11",dir=both];
 11 -> 12 [label="6,7n12,13",dir=both];

 }
 }


 // Nodes
 node [shape=box, fillcolor=lightgray, style="filled, rounded"];
 6 [label="Decision Wrapper",fillcolor=lightyellow];
 15 [label="PersonalnZone Proxy"];
 16 [label="Data Reader"];
 17 [label="RequestnContext"];

 {rank = max; 15}

 // Arcs
 6 -> 8 [label="3,17"];
 8 -> 9 [label="4,16",dir=both];
 14 -> 16 [label="9,10" dir=both];
 7 -> 16 [label="b,c",dir=both,minlen=4];
 16 -> 17 [dir=both];
 17 -> 15 [dir=both];
 15 -> 12 [label="0"];
 15 -> 6 [label="2,18",dir=both,minlen=6];
 }

 // Arcs
 1 -> 4;
 4 -> 15 [label="1"];
}
</div>



h3. Flow description

0. PZP update policies and make them available to the PDP
1. The remote access requestor sends an access request to the PZP across the overlay network
2. The PZP sends the request for access to the decision wrapper
3. The decision wrapper forwards the request towards the access manager, together with the possible relevant
data handling policies attached to the requested resources

_XACML engine branch_
{
 4. The access manager forwards the request to the PEP
 5. The PEP forwards the request to the context handler
 6. The context handler constructs an XACML request and sends it to the PDP
 7. The PDP requests any additional attributes from the context handler.
 8. The context handler requests the attributes from a PIP
 9. The PIP asks the data reader for requested attributes
 10. The PIP obtains the requested attributes
 11. The PIP returns the requested attributes to the context handler
 12. The context handler sends the requested attributes to the PDP which evaluates the policy
 13. The PDP returns the authorization decision to the context handler
 14. The context handler translates the response to the native response format of the PEP and returns
 the response to the PEP
 15. The PEP fulfils the obligations
 16. The PEP returns the access decision to the access manager
}

_Privacy enhanced branch_
{
 a. The access manager forwards the request and the Data Handling Policies to the DHDF engine
 b. The DHDF engine asks the data reader for evaluation information
 c. The DHDF engine obtains information needed for evaluation
 d. The DFDH engine evaluated DH policies and returns the decision to the access manager
}

17. The access manager combines the XACML access control decision and the DHDF data handling decision,
 then it sends the result to the decision wrapper.
18. The decision wrapper forwards the result to the PZP which enforces it.


h3. Functional and non functional requirements

Security requirements selected from "D2.2 Requirements and Developer Experience Analysis" deliverable ([[Spec_-_Security#D022|D022]])

"ID-USR-Oxford-20":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#ID-USR-Oxford-20
"ID-DWP-POLITO-101":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#ID-DWP-POLITO-101
"ID-DEV-POLITO-004":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#ID-DEV-POLITO-004
"ID-DEV-POLITO-017":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#ID-DEV-POLITO-017
"ID-DEV-POLITO-018":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#ID-DEV-POLITO-018
"ID-USR-DT-02":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#ID-USR-DT-02
"ID-USR-POLITO-010":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#ID-USR-POLITO-010
"ID-USR-POLITO-011":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#ID-USR-POLITO-011
"ID-USR-POLITO-013":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#ID-USR-POLITO-013
"ID-DWP-POLITO-014":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#ID-DWP-POLITO-014
"DA-DEV-ISMB-004":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#DA-DEV-ISMB-004
"PS-USR-Oxford-103":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-103
"PS-USR-Oxford-104":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-104
"PS-USR-Oxford-16":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-16
"PS-USR-Oxford-17":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-17
"PS-USR-Oxford-41":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-41
"PS-DMA-IBBT-003":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DMA-IBBT-003
"PS-USR-POLITO-012":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-POLITO-012
"PS-USR-Oxford-67":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-67
"PS-USR-TSI-13":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-TSI-13
"PS-DEV-Oxford-28":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-Oxford-28
"PS-USR-Oxford-30":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-30
"PS-USR-Oxford-54":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-54
"PS-USR-Oxford-55":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-55
"PS-DEV-Oxford-87":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-Oxford-87
"PS-USR-ambiesense-32":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-ambiesense-32
"PS-USR-VisionMobile-10":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-VisionMobile-10
"PS-DEV-VisionMobile-11":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-VisionMobile-11
"PS-DWP-VisionMobile-12":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DWP-VisionMobile-12
"PS-DEV-ambiesense-14":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-ambiesense-14
"PS-DEV-ambiesense-15":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-ambiesense-15
"PS-USR-Oxford-113":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-113
"PS-USR-Oxford-35":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-35
"PS-USR-Oxford-37":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-37
"PS-USR-Oxford-38":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-38
"PS-USR-Oxford-40":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-40
"PS-USR-Oxford-49":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-49
"PS-USR-Oxford-50":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-50
"PS-USR-Oxford-52":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-52
"PS-USR-Oxford-53":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-53
"PS-DWP-POLITO-003":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DWP-POLITO-003
"PS-USR-Oxford-58":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-58
"PS-USR-Oxford-75":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-75
"PS-USR-Oxford-80":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-80
"PS-USR-Oxford-84":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-84
"PS-DEV-IBBT-004":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-IBBT-004
"PS-USR-Oxford-114":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-114
"PS-USR-Oxford-42":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-42
"PS-USR-Oxford-43":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-43
"PS-DMA-DEV-Oxford-47":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DMA-DEV-Oxford-47
"PS-USR-Oxford-48":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-48
"PS-DEV-Oxford-56":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-Oxford-56
"PS-ALL-Oxford-61":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-ALL-Oxford-61
"PS-USR-Oxford-73":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-73
"PS-DEV-Oxford-79":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-Oxford-79
"PS-USR-Oxford-81":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-81
"PS-USR-Oxford-82":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-82
"PS-USR-Oxford-83":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-83
"PS-USR-ISMB-036":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-ISMB-036
"PS-DEV-ambiesense-25":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-ambiesense-25
"PS-USR-DEV-Oxford-44":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-DEV-Oxford-44
"PS-USR-DEV-Oxford-45":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-DEV-Oxford-45
"PS-USR-DEV-Oxford-46":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-DEV-Oxford-46
"PS-USR-Oxford-57":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-57
"PS-DEV-Oxford-64":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-Oxford-64
"PS-USR-Oxford-69":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-69
"PS-USR-Oxford-72":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-72
"PS-DEV-Oxford-88":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-Oxford-88
"PS-DEV-Oxford-89":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-Oxford-89
"PS-USR-Oxford-102":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-102
"PS-USR-Oxford-123":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-123
"PS-DEV-ambiesense-21":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DEV-ambiesense-21
"PS-USR-Oxford-116":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-116
"PS-USR-Oxford-34":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-34
"PS-USR-Oxford-59":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-59
"PS-USR-TSI-3":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-TSI-3
"PS-DWP-ISMB-202":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-DWP-ISMB-202
"PS-USR-Oxford-120":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#PS-USR-Oxford-120
"NC-DEV-IBBT-009":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#NC-DEV-IBBT-009
"NC-DWP-IBBT-0010":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#NC-DWP-IBBT-0010
"NC-DEV-IBBT-0015":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#NC-DEV-IBBT-0015
"LC-DEV-ISMB-003":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#LC-DEV-ISMB-003
"LC-DEV-ISMB-006":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#LC-DEV-ISMB-006
"LC-USR-ISMB-039":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#LC-USR-ISMB-039
"CAP-DEV-SEMC-001":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#CAP-DEV-SEMC-001
"TMS-DWP-POLITO-004":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#TMS-DWP-POLITO-004
"TMS-DWP-POLITO-005":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#TMS-DWP-POLITO-005
"TMS-DWP-POLITO-006":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#TMS-DWP-POLITO-006
"TMS-DWP-VOLANTIS-013":http://dev.webinos.org/redmine/projects/wp2-2/wiki/DeliverableVersionAll#TMS-DWP-VOLANTIS-013

References
----------

### ACSOAS

"Access Control Service Oriented Architecture Security":http://www1.cse.wustl.edu/~jain/cse571-09/ftp/soa/index.html

### BONDIA&S

"BONDI’s Architecture and Security Appendices":http://bondi.omtp.org/1.11/security/BONDI_Architecture_and_Security_Appendices_v1.1.pdf, January 2010

### D022

"D2.2 Requirements & developer experience analysis":http://webinos.org/content/webinos-Requirements_v1.0.3.pdf, February 2011

### D035

"D3.5: Security Architecture - Webinos Project Deliverable":http://dev.webinos.org/redmine/projects/t3-5/wiki/Deliverable_Outline, June 2011.

### DAPWG

"Device APIs and Policy Working Group":http://www.w3.org/2009/dap/

### OASISXACML

"OASIS eXtensible Access Control Markup Language (XACML) TC":http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=xacml

### PRIMELIFE

"PrimeLife":http://www.primelife.eu/

### RFC3986

"Uniform Resource Identifier (URI): Generic Syntax":http://www.ietf.org/rfc/rfc3986.txt, January 2005

### SUNXACML

"Sun’s XACML Implementation":http://sunxacml.sourceforge.net/guide.html

### WACCS

"WAC Core Specification: Widget Security and Privacy":http://specs.wacapps.net/2.0/jun2011/core/widget-security-privacy.html, June 2011

### WACDS

"WAC Device Specifications":http://specs.wacapps.net/2.0/jun2011/index.html, June 2011

### WACXMLSP

"WAC: XML definition of Security Policy (RelaxNG)":http://specs.wacapps.net/2.0/jun2011/core/wacxml.rnc

