[SM] @Main editor: please put <span style="background:yellow">[[Background - Access Control Policy]], [[Background - Privacy Policy]] and [[Policy Editor]]</span> in the informative section if exists..

{{toc}}

Policy
======

The role of the policy manager is to enforce privacy and access control requests, coming from local and remote requesters, in order to manage the disclosure of personal data and to control access to personal zone device capabilities and features.
The aforementioned process is done by matching requests to resources against written policies in order to determine an access control decision. This decision could be to allow or deny access to the requested resources, or involve further interaction and consent with the resource owner.

In the following sessions a brief background overview is provided and specifications will follow up. Aspects that will be taken into consideration are access control and privacy policies and the synchronization mechanisms. Furthermore the policy grammar and some examples will be presented.

Conceptual architecture
=======================

The webinos platform’s security and privacy goals are primarily achieved through the introduction of an _access control policy architecture_ based on [[Policy#XACML|XACML]] integrated with extensions from [[Policy#PrimeLife|PrimeLife]]

The main motivations behind the choice of the PrimeLife extension, other than the support of data-handling privacy policies are:
* Support for credential-based restrictions (digital credential and certified attributes)
* Legislation support (EU privacy directives)
* PrimeLife is an open-source European Project

The complete architecture - the components for which are described and depicted below - contains, as well as than the XACML/PrimeLife components, a PZH and a PZP defined in the high level webinos architecture and the PDPC (PDPCache) generally included in XACML’s PDP component. The architecture is composed of the following elements:

_**Access Requestor**_: the entity which requires and requests access to a resource. For example, an application may request access to a service defined by a webinos API.

_**Personal Zone Hub (PZH)**_/ _**Personal Zone Proxy (PZP)**_: defined in the preceding sections, in this context it can act in two ways:

1.  verify credentials
2.  enforce authorization decisions

_**Decision Wrapper**_: responsible for driving the access control policy evaluation and enforcement.

_**Access Manager**_: the entity in charge of taking the final decision by combining the XACML access control and the DHDF data.

_**DHDF Engine**_: Data Handling Decision Function engine provides privacy and data handling functionalities.
It does not implement a complete privacy-aware access control system, but rather it is responsible for
the management and evaluation of data handling policies only.

_**Policy Enforcement Point (PEP)**_: the entity that performs access control, by making decision requests and enforcing authorization decisions. It also tries to execute the Obligations and doesn’t grant access if is unable to complete these actions.

_**Policy Decision Point (PDP)**_: the main decision point for the access requests. It collects all the necessary information from other actors and concludes an authorization decision.

_**PDPC**_: the PDP cache, stores PDP decisions.

_**Policy Information Point (PIP)**_: the entity that acts as a source of attribute values that are retrieved from several internal or external parties like resources, subjects, environment and so on.

![](architecture.png)

The data flow sequence is exposed by the three scenarios presented in the "Formal Specification" paragraph.

Access Control Policies
=======================

Policy Format
-------------

Webinos’ policies are expressed in the simplified XACML format defined for the first time in "BONDI’s Architecture & Security Requirements (Appendices) v1.1" ([[Policy#BONDIA38S|BONDIA&S]]) and following the grammar provided by WAC ([[Policy#WACXMLSP|WACXMLSP]]). This format has been used as a basis in different specifications as W3C DAP ([[Policy#DAPWG|DAPWG]]) and WAC ([[Policy#WACDS|WACDS]]).
Starting from the same format some changes are introduced to fulfill webinos’ requirements due to the different structures and aims of the mentioned frameworks.

The main updates to the BONDI policy format are:
* Some new attributes related to the subject’s information to fit webinos’ requirements for distribution of policies between devices and cross device interaction.
* Two new attributes related to the resource’s information required to identify services and the extensions that could be declared in an application manifest.
* Privacy policy elements that are discussed here in [[Policy#Privacy-and-data-handling-policies|Privacy and data handling policies]] subsection.

Policy Subject
--------------

Given a policy, the policy subject define the entity to which the policy will be applied. The set of subjects to which the policy or policy set applies is called target.

Each subject respects the following template:

"User U can access Feature F of Device D through the application A running in a Device X".

"Device D" is also identified as target device whilst the "Device X" is identified as requestor device.

There are four basic information points in this template:

1.  WHO want to access a resource: could be an user or a list of users
2.  WHERE the access requestor is: it should be possible to differentiate a local access (INTRA-DEVICE) from a remote access (INTRA-PZ or EXTRA-PZ)
3.  WHERE the resource is: allow the same policy file to be used by many devices
4.  WHICH application is used: could be used to differentiate behaviour for applications from different authors, distributors, and other attributes

It’s possible that some or all subject’s attributes are not specified in a given subject. In these cases, the default values will be used to represent missing information.

Subject Attributes
------------------

The subject attributes are divided in three groups:

1.  Apps
2.  Devices
3.  User

### Apps attributes

The first group comes from the "B.4 Subject Attributes" section of ([[Policy#BONDIA38S|BONDIA&S]]) and defines the properties used to identify widgets and browser-based applications.
In case of widgets, recognized or unrecognised (see [[Entity_Definitions#Webinos-application|Webinos application]]), the attributes are:

  ---------------------------------- ------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _.Attribute                   _.Type   _.Value
  class                              String        This has the value "w-r" or "w-u" if and only if the subject is respectively a recognized widget or an unrecognized one.
  install-uri                        URI           The URI that the Widget Resource was originally retrieved from before installation, if known, otherwise the empty bag.
  id                                 URI           The identity of the Widget. For a W3C Widget specification compliant Widget Resource, this is the value of the id attribute of the <widget> element in the Widget Configuration Document converted from IRI to URI based on RFC3987. In this case, it is a URI that uniquely identifies the Widget. Empty bag if there is no id attribute.
  version                            String        Version of the Widget Resource. For a W3C Widget specification compliant Widget Resource, this is the version attribute of the <widget> element in the Widget Configuration Document. Empty bag if there is no version attribute.
  distributor-key-cn                 String        The common name of the end entity certificate for the applicable Widget Resource distributor signature. Empty bag if none.
  distributor-key -fingerprint       String        The fingerprint of the end-entity certificate for the applicable Widget Resource distributor signature. Empty bag if none.
  distributor-key-root-cn            String        The common name of the root certificate for the applicable Widget Resource distributor signature. Empty bag if none.
  distributor-key-root-fingerprint   String        The fingerprint of the root certificate for the applicable Widget Resource distributor signature.Empty bag if none.
  author-key-cn                      String        The common name of the end entity certificate for the Widget Resource author signature. Empty bag if none.
  author-key-fingerprint             String        The fingerprint of the end entity certificate for the Widget Resource author signature in SDP syntax. Empty bag if none.
  author-key-root-cn                 String        The common name of the root certificate for the Widget Resource author signature. Empty bag if none.
  author-key-root-fingerprint        String        The fingerprint of the root certificate for the Widget Resource author signature. Empty bag if none.
  widget-attr:name                                 The value of the named attribute of the <widget> element whose type and value are set up in the Widget Configuration Document for use in the security framework. Empty bag if no such named attribute is defined.
  ---------------------------------- ------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

In case of browser-based applications the attributes are:

  ---------------------- ------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _.Attribute       _.Type   _.Value
  class                  String        This has the value "b-a" if and only if the subject is a browser-based authenticated application.
  sign-schema            String        The value will be â€œâ€ (empty string) or "tlsâ€ if the page was fetched using HTTPS and the browser has verified that the site certificateâ€™s Common Name matches the host that the page was fetched from, and it has already applied its own policies regarding whether the root certificate is in an acceptable trust domain. â€œtls-evâ€ if as â€œtlsâ€, and, additionally, the site certificate has an extended validation field and the browser’s internal policy allows that information to be passed to the security framework.
  uri                    URI           The URI used to access the document that embeds or refers to the JavaScript code, corresponding to the window.location property of the browsing context. In the case of that a Feature is accessed from a child browsing context (for example from within a <iframe> within some outer document), this attribute provides the location of the child context.
  uri-top                URI           The URI used to access the browser-based application that embeds or refers to the JavaScript code, corresponding to the top.window property of the browsing context. In the case that the Feature is accessed from a child browsing context (for example from within an <iframe>), this attribute provides the location of the top-level browsing context. If the current browsing context is a child of a Widget top-level browsing context, this attribute contains an IRI with the widget: scheme that corresponds to the top-level containing document from the Widget Resource.
  key-root-cn            String        The common name of the root certificate chained to by the site certificate.
  key-root-fingerprint   String        The fingerprint of the root certificate chained to by the site certificate.
  ---------------------- ------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The attributes "id", "uri" and "uri-top" other than the values presented (defined also in [[Policy#BONDIA38S|BONDIA&S]]) could contain one of the following URIs:

-   http://webinos.org/subject/id/known
-   http://webinos.org/subject/id/unknown

respectively if the widgets and browser-based applications were previously installed or not. If none of the apps attributes is specified then will be used the default value representing any widget/browser-based application:

-   http://webinos.org/subject/id/any

**Note:** Browser-based applications can access webinos only if they are served from an origin with scheme HTTPS (see [[Application_Security_and_Secure_Communication#22-First-use-of-a-browser-based-application|First use of a browser based application]] for further details)

### Devices attributes

Devices attributes are used in order to express whether a device acts as a requestor or is a target, specifying its ID, domain and whether it is webinos enabled.
If the target-id is absent then the target device will be the _current device_ and in a similar way if the requestor-id is absent the requestor will be the _current device_.
The _current device_ is the device whose policy manager is reading the policy to enforce an access request.

  ------------------ ------------- ------------------------------------------------------------------------------------------------------------------------------------------------ ------------------------------------------- ---------------------------
  _.Attribute   _.Type   _.Value
  target-id          URI           ID of the device where the policy will be enforced. An ID could be a generic device URI (see list below) or refer to [[Entity_Definitions
  target-domain      URI           Domain of the target device. Refer to the domain URIs listed below
  requestor-id       URI           ID of the device requesting resources. An ID could be a generic device URI (see list below) or a PZP generated one
  requestor-domain   URI           Domain of the requestor device. Refer to the domain URIs listed below
  webinos-enabled    Boolean       True if requestor device is webinos enabled. If this attribute is not specified doesn’t matter if the device is webinos enabled or not
  ------------------ ------------- ------------------------------------------------------------------------------------------------------------------------------------------------ ------------------------------------------- ---------------------------

_**Generic device URIs:**_
* http://webinos.org/subject/id/device
* http://webinos.org/subject/id/known
* http://webinos.org/subject/id/unknown
* http://webinos.org/subject/id/any (default)

In this context these URIs represent respectively the _current device_ , a device whose certificate is already known, a device whose certificate is currently unknown and any device.
The _current device_ is the device whose policy manager is reading the policy to enforce an access request.

_**Domain URIs:**_
* http://webinos.org/subject/domain/automotive
* http://webinos.org/subject/domain/desktop
* http://webinos.org/subject/domain/home-media
* http://webinos.org/subject/domain/mobile

http://webinos.org/subject/domain/any is the default domain URI value and represents all domains.

### User attributes

The User attributes allow to define the user to which a policy is referred. If the user-id is absent then the subject refers to any user.

  --------------------------- ------------- ---------------------------------------------------------------------------------------------------------------------------------------------- ------------------------------------------- ---------------------------
  _.Attribute            _.Type   _.Value
  user-id                     URI           ID of the user to which the policy will be applied. An ID could be a generic user URI (see list below) or refer to [[Entity_Definitions
  user-key-cn                 String        The common name of the certificate for the user signature
  user-key-fingerprint        String        The fingerprint of the certificate for the user signature
  user-key-root-cn            String        The common name of the root certificate for the user signature
  user-key-root-fingerprint   String        The fingerprint of the root certificate for the user signature
  --------------------------- ------------- ---------------------------------------------------------------------------------------------------------------------------------------------- ------------------------------------------- ---------------------------

_**Generic user URIs:**_
* http://webinos.org/subject/id/device
* http://webinos.org/subject/id/known
* http://webinos.org/subject/id/unknown
* http://webinos.org/subject/id/any (default)
* http://webinos.org/subject/id/PZ-Owner

In this context these URIs represent respectively the owner of the _current device_, an user whose certificate is already known, an user whose certificate is currently unknown, any user, and the Personal Zone Owner.
The _current device_ is the device whose policy manager is reading the policy to enforce an access request.

Resource Attributes
-------------------

The following table lists the resource attributes as defined in "B.5 Resource Attributes" section of ([[Policy#BONDIA38S|BONDIA&S]]), to which we added the service-id resource:

  ------------------------------ ------------- ------------------------------------------------------------------------------------------------------------
  _.Attribute               _.Type   _.Value
  api-feature                    URI           The Identifier of the requested feature
  device-cap                     String        The Identifier of the device capability being accessed
  param:name                     See comment   The value of parameter â€œnameâ€. This value is determined only in the invoke execution phase
  feature-install-uri            URI           The URI that the API implementation was originally retrieved from before installation
  feature-key-cn                 String        The common name of the end entity certificate for the signature associated with the feature implementation
  feature-key-root-cn            String        The common name of the root certificate for the signature associated with the feature implementation
  feature-key-root-fingerprint   String        The fingerprint of the root certificate of the signature associated with the feature implementation
  service-id                     String        The Identifier of the requested service
  ------------------------------ ------------- ------------------------------------------------------------------------------------------------------------

Attribute match
---------------

The attribute match statement comes from section B.7 of [[Policy#BONDIA38S|BONDIA&S]] specification. It represents the evaluation of an attribute against a value and can return true, false or indeterminate as result.

An attribute match takes the name of subject match or resource match respectively if the attribute being evaluated is a subject or a resource attribute.

An attribute match statement can be represented by the following functions:

<pre><code class="javascript">
 matchfunc( modifierfunc( attr ), value )
</code></pre>

<pre><code class="javascript">
 matchfunc( attr, value )
</code></pre>

Where `matchfunc` is the matching function that requires two non-boolean inputs and whose result is a boolean or is undetermined if at least one input is undetermined.
The `modifierfunc` is a function that operates on a non-boolean input and whose result is a non-boolean value or is undetermined if its input is undetermined.

Subject specification
---------------------

The subject specification element comes from section B.8 of [[Policy#BONDIA38S|BONDIA&S]] specification. It consists of a conjunctive sequence of subject matches. A subject specification is evaluated as follows:
* is determined and has value TRUE if each of the subject matches has value TRUE
* otherwise, is undetermined if any or the subject matches is undetermined
* otherwise is determined and has value FALSE.

A subject has an id attribute. If an implementation provides a means to provision a security policy fragment to replace an existing one, this id can be used to identify the subject to replace. No management of ids is mandated, therefore it is recommended that a standardised textual representation of a UUID should be used as the id.

A subject match is an attribute match where the attribute being matched is a subject attribute, and the match value is a literal string.

Target
------

The target element comes from section B.9 of [[Policy#BONDIA38S|BONDIA&S]] specification. The target of a policy or policy set identifies the set of subjects to which the policy or policy set applies. It consists of a disjunctive sequence of subject specifications and is evaluated as follows:
* has value TRUE if at least one of the subject specifications has value TRUE
* otherwise has value FALSE.

A policy or policy-set that has no target explicitly specified is treated as having a target that evaluates unconditionally to TRUE.
The target has an id attribute. No management of ids is mandated, therefore it is recommended that a standardised textual representation of a UUID should be used as the id.

Decision
--------

The decision is defined in section B.10 of [[Policy#BONDIA38S|BONDIA&S]] specification.
If determined, the result of a rule or policy or policy set is a decision, either "not applicable" or any one of the effects "permit", "prompt-blanket", "prompt- session", "prompt-oneshot" or "deny". The effects are defined in [[Policy#Effect|Effect]].
The result of a rule or policy or policy set may be undetermined under conditions specified for each below.

Rule
----

The rule element comes from section B.11 of [[Policy#BONDIA38S|BONDIA&S]] specification. It consists of a [[Policy#Condition|condition]], and a [[Policy#Effect|effect]] attribute.
A rule has also an id. If an implementation provides a means to provision a security policy fragment to replace an existing one, this id can be used to identify the rule to replace. No management of ids is mandated, therefore it is recommended that a standardised textual representation of a UUID should be used as the id.
The result of a rule (see [[Policy#Decision|decision]]) is determined if and only if its condition has a determined value.

Condition
---------

The condition of a rule (section B.12 of [[Policy#BONDIA38S|BONDIA&S]] specification) specifies extra criteria that need to be matched before the rule becomes applicable.
The condition consists of one or more attribute matches, combined with AND and OR operators into an arbitrarily nested tree.
The AND operator is evaluated as follows:
* is determined and has value "no match" if any input is "no match";
* otherwise is undetermined if any input is undetermined;
* otherwise is determined and has value "match".

The OR operator is evaluated as follows:
* is determined and has value "match" if any input is "match";
* otherwise is undetermined if any input is undetermined;
* otherwise is determined and has value "no match".

Policy
------

The policy element comes from section B.13 of [[Policy#BONDIA38S|BONDIA&S]] specification. A policy has a target, and a list of zero or more rules combined using a rule-combining algorithm (see [[Policy#Combining-algorithm|Combining algorithm]] for the combining algorithms). Where a directive attribute query finds more than one applicable directive attribute set, the first one is used.
A policy optionally has a textual description. It has also an id. If an implementation provides a means to provision a security policy fragment to replace an existing one, this id can be used to identify the policy to replace. No management of ids is mandated, therefore it is recommended that a standardised textual representation of a UUID should be used as the id.
The result of a policy is determined if and only if its combining rule has determined value.

Policy set
----------

The policy set element comes from section B.14 of [[Policy#BONDIA38S|BONDIA&S]] specification.
A policy set is an element with a list of zero or more policies or policy sets combined using a policy-combining algorithm (see [[Policy#Combining-algorithm|Combining algorithm]] for the combining algorithms). Where a directive attribute query finds more than one applicable directive attribute set, the first one is used.
A policy set has an id. If an implementation provides a means to provision a security policy fragment to replace an existing one, this id can be used to identify the policy set to replace. No management of ids is mandated, therefore it is recommended that a standardised textual representation of a UUID should be used as the id.

The result of a policy is determined if and only if its combining rule has determined value.

Matching function
-----------------

As defined in section B.17 of [[Policy#BONDIA38S|BONDIA&S]] specification the matching function used in an attribute match is one of the following:

### String equality matching function

True if and only if some string from one input string bag is byte-for-byte equal to some string from the other input string bag. Thus an empty bag is not equal to anything, not even another empty bag. An input of type other than empty bag or string bag is converted to string bag first.

### Globbing matching function

True if and only if, for some string in the first input string bag, the entire string matches the glob pattern in some string in the second input string bag. If either input is the empty bag, the result is false. An input of type other than empty bag or string bag is converted to string bag first.

### Regular expression matching function

True if and only if, for some string in the first input string bag, some part of the string matches the regular expression pattern in some string in the second input string bag. If either input is the empty bag, the result is false. An input of type other than empty bag or string bag is converted to string bag first.
This uses the definition of regular expressions in ECMAScript 3rd edition.

Combining algorithm
-------------------

As defined in section B.19 of [[Policy#BONDIA38S|BONDIA&S]] specification there are two types of combining algorithms: policy-combining algorithms and rule-combining algorithms.
The policy-combining algorithm for a policy set determines how child policies and policy sets are combined.
The rule-combining algorithm for a policy determines how child rules are combined.
The algorithms are described in the following subsections. The term child is used to mean the child rules in the policy when applying the policy’s rule- combining algorithm, or the child policies and policy sets in the policy set when applying the policy set’s policy-combining algorithm.

### Deny-overrides combining algorithm

The deny-overrides combining algorithm is usable as a policy-combining algorithm and as a rule-combining algorithm. The overall result of a query is evaluated as follows.
* If any child evaluates to "deny", then the overall result is "deny".
* Otherwise, if any child is undetermined, then the overall result is undetermined.
* Otherwise, if any child evaluates to "prompt-oneshot", then the overall result is "prompt-oneshot".
* Otherwise, if any child evaluates to "prompt-session", then the overall result is "prompt-session".
* Otherwise, if any child evaluates to "prompt-blanket", then the overall result is "prompt-blanket".
* Otherwise, if any child evaluates to "permit", then the overall result is "permit".
* Otherwise, the overall result is "inapplicable".

### Permit-overrides combining algorithm

The permit-overrides combining algorithm is usable as a policy-combining algorithm and as a rule-combining algorithm.The overall result of a query is evaluated as follows.
* If any child evaluates to "permit", then the overall result is "permit"
* Otherwise, if any child is undetermined, then the overall result is undetermined.
* Otherwise, if any child evaluates to "prompt-blanket", then the overall result is "prompt-blanket".
* Otherwise, if any child evaluates to "prompt-session", then the overall result is "prompt-session".
* Otherwise, if any child evaluates to "prompt-oneshot", then the overall result is "prompt-oneshot".
* Otherwise, if any child evaluates to "deny", then the overall result is "deny".
* Otherwise, the overall result is "inapplicable".

### First-applicable rule combining algorithm

The first-applicable rule combining algorithm is usable as a rule-combining algorithm.
The overall result of a query is evaluated by processing the children in written order as follows:
* if the current child is determined and does not evaluate to "inapplicable", the overall result is the result of the current child;
* otherwise, if the current child is undetermined, the overall result is undetermined;
* otherwise, if the current child is determined and has value "inapplicable", continue processing at the next child. If already processing the final child, the overall result is "inapplicable".

### First-matching-target policy combining algorithm

The first-matching-target policy combining algorithm is usable as a policy- combining algorithm.
The overall result of a query is evaluated by processing the children in written order as follows:
* if the current child has a target that matches the overall result is the result of the current child;
* otherwise, continue processing at the next child. If already processing the final child, the overall result is "inapplicable".

Effect
------

As defined in section B.20 of [[Policy#BONDIA38S|BONDIA&S]] specification the effect of a rule is one of the following:

### Permit

This effect allows requested access without user interaction.

### Deny

This effect denies requested access without user interaction.

### Prompt-X

The prompt-oneshot, prompt-session and prompt-blanket effects allow requested access after explicit confirmation by the user. The implementation MUST prompt the user before allowing access.
The implementation MUST only provide the user the option to grant permission up to the maximum allowed by the effect, ie:
* prompt-oneshot: "deny always", "deny this time", "allow this time";
* prompt-session: prompt-oneshot options plus "deny for this session", "allow for this session";
* prompt-blanket: prompt-session options plus "allow always".

The implementation MUST provide a means to respond with any available option that is applicable in the context in which the prompt is displayed.
Any default action MUST be at least as restrictive as "deny this time".
If the user has the option of deferring a response indefinitely and the user does not respond explicitly, the requested access MUST NOT be allowed.
For a Widget, a session lasts while the application is still running and the terminal has not been switched off or placed in standby mode.
For a browser-based application, another visit to the same page in the same Browser tab or window is part of the same session.

Query
-----

As defined in section B.21 of [[Policy#BONDIA38S|BONDIA&S]] specification a query represents a specific instance of a security policy being evaluated in order to make an access control decision relating to an attempted operation by a Web Application.
A query is characterised by the collection of subject attributes associated with the Web Application instance, the collection of resource attributes associated with the attempted operation, and the collection of environment attributes associated with the circumstances of the attempt. The determinedness of each of these attributes is in accordance with the execution phase of the attempt.
A query is evaluated against a policy-set, resulting in a decision in accordance with the evaluation rules defined in this specification.

Core features
-------------

The following table contains some core features referring to widget lifecycle, WRT, network access and policy control functionalities. These features are not associated to APIs and correspond to action performed or controlled by the Widget Manager and the Widget Runtime. It’s not required to declare these features inside any widget configuration document.

  -------------------------------------------- ---------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------
  _.Feature                               _.Meaning                                             _.Parameters
  http://webinos.org/core/widget/install       Identifies the widget installation process                 
  http://webinos.org/core/widget/instantiate   Identifies the widget instantiation                        
  http://webinos.org/core/widget/update        Identifies the widget update process                       
  http://webinos.org/core/widget/uninstall     Identifies the widget removal                              
  http://webinos.org/core/wrt/update           Identifies the widget update process                       
  http://webinos.org/core/network-access       Identifies network IO operation operated by widgets.       param (_uri_) to identify the remote resource accessed, _roaming_ to indicate roaming status
  http://webinos.org/core/xhr                  Identifies network IO operation operated by widgets.       param (_uri_) to identify the remote resource accessed, _roaming_ to indicate roaming status
  http://webinos.org/core/policy-management    Identifies operations related to policy files management   
  -------------------------------------------- ---------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------

API features
------------

|_.Feature |_.API |_.Parameters example |
| http://webinos.org/api/actuators |/8.Generic Actuator |/8. |
| http://webinos.org/api/actuators/switch |
| http://webinos.org/api/actuators/linearmotor |
| http://webinos.org/api/actuators/rotationalmotor |
| http://webinos.org/api/actuators/vibratingmotor |
| http://webinos.org/api/actuators/servomotor |
| http://webinos.org/api/actuators/swivelmotor |
| http://webinos.org/api/actuators/thermostat |
| http://webinos.org/api/app2app | App2App Messaging | |
| http://webinos.org/api/sync |/3.AppState Synchronisation |/3. |
| http://webinos.org/api/sync/find |
| http://webinos.org/api/sync/watch |
| http://webinos.org/api/authentication | Authentication | |
| http://webinos.org/api/contacts |/3.Contacts |/3.id - id of the contact |
| http://webinos.org/api/contacts/read |
| http://webinos.org/api/contacts/write |
| http://webinos.org/api/deviceinteraction | Device Interaction | |
| http://webinos.org/api/devicestatus |/9.Device Status |/9.component,
 aspect,
 property |
| http://webinos.org/api/devicestatus/getproperty |
| http://webinos.org/api/devicestatus/watchproperty |
| http://webinos.org/api/devicestatus/deviceinfo |
| http://webinos.org/api/devicestatus/deviceinfo/getproperty |
| http://webinos.org/api/devicestatus/deviceinfo/watchproperty |
| http://webinos.org/api/devicestatus/networkinfo |
| http://webinos.org/api/devicestatus/networkinfo/getproperty |
| http://webinos.org/api/devicestatus/networkinfo/watchproperty |
| http://webinos.org/api/events |/3.Event Handling |/3. |
| http://webinos.org/api/events/create |
| http://webinos.org/api/events/listen |
| http://webinos.org/api/applauncher |/3. AppLauncher |/3.appId |
| http://webinos.org/api/applauncher/launch |
| http://webinos.org/api/applauncher/check |
| http://webinos.org/api/mediacontent |/5.MediaContent |/5.MediaItemId - Identifier of the mediaItem;
 MediaDirectoryId - Identifier of the mediaDirectory |
| http://webinos.org/api/mediacontent/read |
| http://webinos.org/api/mediacontent/read/find |
| http://webinos.org/api/mediacontent/read/listen |
| http://webinos.org/api/mediacontent/write |
| http://webinos.org/api/mediaplay | MediaPlay | locationURI - URI of resources allowed or not to be accessed |
| http://webinos.org/api/navigation | Navigation | |
| http://webinos.org/api/nfc |/3.NFC |/3. |
| http://webinos.org/api/nfc/read |
| http://webinos.org/api/nfc/write |
| http://webinos.org/api/notifications | Web Notification | |
| http://webinos.org/api/payment | Payment API | |
| http://webinos.org/api/remoteUI | Remote UI | |
| http://webinos.org/api/secureelement | Secure Element | aid - Identifier of the applet |
| http://webinos.org/api/sensors |/24.Generic Sensor |/24. |
| http://webinos.org/api/sensors/configure |
| http://webinos.org/api/sensors/read |
| http://webinos.org/api/sensors/light |
| http://webinos.org/api/sensors/light/configure |
| http://webinos.org/api/sensors/light/read |
| http://webinos.org/api/sensors/noise |
| http://webinos.org/api/sensors/noise/configure |
| http://webinos.org/api/sensors/noise/read |
| http://webinos.org/api/sensors/temperature |
| http://webinos.org/api/sensors/temperature/configure |
| http://webinos.org/api/sensors/temperature/read |
| http://webinos.org/api/sensors/pressure |
| http://webinos.org/api/sensors/pressure/configure |
| http://webinos.org/api/sensors/pressure/read |
| http://webinos.org/api/sensors/proximity |
| http://webinos.org/api/sensors/proximity/configure |
| http://webinos.org/api/sensors/proximity/read |
| http://webinos.org/api/sensors/humidity |
| http://webinos.org/api/sensors/humidity/configure |
| http://webinos.org/api/sensors/humidity/read |
| http://webinos.org/api/sensors/heartratemonitor |
| http://webinos.org/api/sensors/heartratemonitor/configure |
| http://webinos.org/api/sensors/heartratemonitor/read |
| http://webinos.org/api/discovery | Discovery | URI - URI of the feature that the policy manager will make discoverable or not |
| http://webinos.org/api/tv | TV Control | TVchannel - channel allowed/denied to be accessed |
| http://webinos.org/api/vehicle |/11.Vehicle |/11. |
| http://webinos.org/api/vehicle/climate |
| http://webinos.org/api/vehicle/parksensors |
| http://webinos.org/api/vehicle/tripcomputer |
| http://webinos.org/api/vehicle/lights |
| http://webinos.org/api/vehicle/gearbox |
| http://webinos.org/api/vehicle/engineoil |
| http://webinos.org/api/vehicle/seating |
| http://webinos.org/api/vehicle/tires |
| http://webinos.org/api/vehicle/windows |
| http://webinos.org/api/vehicle/doors |
| http://webinos.org/api/corePZinformation | Webinos core interface | |
| http://webinos.org/api/widget |/2.Webinos Widget |/2. |
| http://webinos.org/api/widget/deploy |
| http://webinos.org/api/w3c/deviceorientation | W3C DeviceOrientation | |
| http://webinos.org/api/w3c/file |/3.W3C File
 W3C FIle: Writer
 W3C File: Directories and System |/3. locationURI - URI that refer to a resource in the filesystem |
| http://webinos.org/api/w3c/file/read |
| http://webinos.org/api/w3c/file/write |
| http://webinos.org/api/w3c/geolocation |/3.W3C Geolocation |/3. enableHighAccuracy - [true/false] if it [is/is not] possible to enable High Accuracy |
| http://webinos.org/api/w3c/geolocation/getposition |
| http://webinos.org/api/w3c/geolocation/watchposition |
| http://webinos.org/api/w3c/mediastream | W3C Media Capture and Streams | sourceType - optional parameter [microphone/camera] |
| http://webinos.org/api/w3c/webrtc | W3C WebRTC | appId - id of recipient application;
 sourceType - mediaStream type;
 locationURI - URI of resources allowed or not to be accessed |

Context features
----------------

|_.Feature |_.Parameters example |
| http://webinos.org/api/context |/11.context query: the query containing either the data to be stored, the conditions of the retrieval or the definition of a new context object;
 API: the API feature URI;
 appId: a unique identifier for the application creating the context object;
 context object name: the name of the context object created by an application. |
| http://webinos.org/api/context/query |
| http://webinos.org/api/context/app |
| http://webinos.org/api/context/app/create |
| http://webinos.org/api/context/app/read |
| http://webinos.org/api/context/schedule |
| http://webinos.org/api/context/schedule/create |
| http://webinos.org/api/context/schedule/read |
| http://webinos.org/api/context/rules |
| http://webinos.org/api/context/rules/create |
| http://webinos.org/api/context/rules/read |

Formal Specification
--------------------

Below are depicted three use cases to show the workflow for:

1.  requests come from an applications inside the device
2.  requests come from outside the Device
3.  requests come from outside the Device, and no Personal Hub is reachable (or it is not contacted for resource usage optimization)

### Distributed architecture, Case 1: requests come from an application inside the device

![](distributed_architecture_1.png)

### Flow description

1. The access requestor sends an access request to the PZP
2. The PZP sends the request for access to the decision wrapper
3. The decision wrapper forwards the request towards the access manager, together with the possible relevant
data handling policies attached to the requested resources

_XACML engine branch_
{
 4. The access manager forwards the request to the PEP
 5. The PEP forwards the request to the PDP
 6. The PDP requests any additional attributes from the PIP
 7. The PIP returns the requested attributes to the PDP which evaluates the policy
 8. The PDP returns the authorization decision to the PEP
 9. The PEP returns the access decision to the access manager
}

_Privacy enhanced branch_
{
 a. The access manager forwards the request and the Data Handling Policies to the DHDF engine
 b. The DHDF engine asks the PIP for evaluation information
 c. The DHDF engine obtains information needed for evaluation
 d. The DFDH engine evaluated DH policies and returns the decision to the access manager
}

10. The access manager combines the XACML access control decision and the DHDF data handling decision,
 then it sends the result to the decision wrapper.
11. The decision wrapper forwards the result to the PZP which enforces it.

### Distributed architecture, Case 2: requests come from outside the Device

![](distributed_architecture_2.png)

### Flow description

1. The remote access requestor sends an access request to the PZH across the overlay network
2. The PZH sends the request for access to the decision wrapper
3. The decision wrapper forwards the request towards the access manager, together with the possible relevant
data handling policies attached to the requested resources

_XACML engine branch_
{
 4. The access manager forwards the request to the PEP
 5. The PEP forwards the request to the PDP
 6. The PDP requests any additional attributes from the PIP
 7. The PIP returns the requested attributes to the PDP which evaluates the policy
 8. The PDP returns the authorization decision to the PEP
 9. The PEP returns the access decision to the access manager
}

_Privacy enhanced branch_
{
 a. The access manager forwards the request and the Data Handling Policies to the DHDF engine
 b. The DHDF engine asks the PIP for evaluation information
 c. The DHDF engine obtains information needed for evaluation
 d. The DFDH engine evaluated DH policies and returns the decision to the access manager
}

10. The access manager combines the XACML access control decision and the DHDF data handling decision,
 then it sends the result to the decision wrapper.
11. The decision wrapper forwards the result to the PZH
12. The PZH forwards the result to the PZP which enforces it.

### Distributed architecture, Case 3: requests come from outside the Device, and no Personal Hub is reachable (or it is not contacted for resource usage optimization)

![](distributed_architecture_3.png)

### Flow description

1. The remote access requestor sends an access request to the PZP across the overlay network
2. The PZP sends the request for access to the decision wrapper
3. The decision wrapper forwards the request towards the access manager, together with the possible relevant
data handling policies attached to the requested resources

_XACML engine branch_
{
 4. The access manager forwards the request to the PEP
 5. The PEP forwards the request to the PDP
 6. The PDP requests any additional attributes from the PIP
 7. The PIP returns the requested attributes to the PDP which evaluates the policy
 8. The PDP returns the authorization decision to the PEP
 9. The PEP returns the access decision to the access manager
}

_Privacy enhanced branch_
{
 a. The access manager forwards the request and the Data Handling Policies to the DHDF engine
 b. The DHDF engine asks the PIP for evaluation information
 c. The DHDF engine obtains information needed for evaluation
 d. The DFDH engine evaluated DH policies and returns the decision to the access manager
}

10. The access manager combines the XACML access control decision and the DHDF data handling decision,
 then it sends the result to the decision wrapper.
11. The decision wrapper forwards the result to the PZP which enforces it.

Privacy and data handling policies
==================================

Specification
-------------

As anticipated in [[Policy#Conceptual-architecture|conceptual architecture]], the webinos platform’s security and privacy requirements are achieved through the definition of an enforcement system based on access control and privacy policies.
While the access control policies are discussed in the previous section, this one focus on privacy and data handling specifications.
The following diagram depicts a brief overview of the mechanisms involving privacy and data handling policies. **_policy.xml_** is the policy file containing all the preferences that the user has specified, **_manifest.xml_** is the application’s manifest.

![](privacyManifest.png)

### Data handling

Data handling refers to the management of user and application data by applications. [[Policy#PrimeLife|PrimeLife]] defines in its "Report on design and implementation" ([[Policy#PrimeLifeRDI|PrimeLifeRDI]]) two different entities involved in data handling:

-   **_data controller_**: which in our case is the application side. Is the entity that receives the data.
-   **_data subject_**: which in the webinos scenario is the PZ, therefore the PZP and the PZH. Is the entity that holds the data.

In webinos data handling policies and preferences are expressed using the PrimeLife Privacy Language (PPL) and the P3P ontology, particularly the authorization tags also described in [[Policy#PrimeLifeRDI|PrimeLifeRDI]]. The definition of Authorizations, Obligations and Provisional actions elements come from this same document.

Data handling policies are defined by the application in its manifest and data handling preferences are defined by the user in a policy.xml file. They both are composed of authorizations and obligations.

#### Authorizations

Authorizations are the first part of data handling where preferences/intentions are declared.
In the policy they are represented by an _<AuthorizationsSet>_ element whose child _<AuthzUseForPurpose>_, contains a list of purposes (_<Purpose>_) authorized to use the information.
In the following example the _<Purpose>_ tag specifies that only the pseudonymous analysis is allowed.

<pre><code class="xml">
<AuthorizationsSet>
 <AuthzUseForPurpose>
 <Purpose>http://www.w3.org/2002/01/P3Pv1/pseudo-analysis</Purpose>
 </AuthzUseForPurpose>
</AuthorizationsSet>
</code></pre>

The purposes associated to the URIs are defined in P3P 1.1 specification ([[Policy#P3P11|P3P11]]).

#### Obligations

Obligations are a subset of data handling where additional constraints are declared. They are specified inside _<Obligation>_ elements, which on their turn contain a _<TriggersSet>_ element describing the events that trigger the obligation, an _<Action>_ element describing the action to be performed, and a _<Validity>_ element describing the validity time frame of the obligation. Set of obligations, can be expressed through an _<ObligationsSet>_ element.

Moreover, in this other section of this example it is required the data deletion (using the _<ActionDeletePersonalData/>_ tag) within five days (using _<StartTime>_ and _<MaxDelay>_ tags).

<pre><code class="xml">
<ObligationsSet>
 <Obligation>
 <TriggersSet>
 <TriggerAtTime>
 <StartTime><StartNow/></StartTime>
 <MaxDelay>
 <Duration>P0Y0M5DT0H0M0S</Duration>
 </MaxDelay>
 </TriggerAtTime>
 </TriggersSet>
 <ActionDeletePersonalData/>
 </Obligation>
</ObligationsSet>
</code></pre>

#### Provisional Actions

Provisional actions are used to bind the authorization set and the obligations.
Moreover, a brief description in a human readable language can be provided by developers for each feature. An attribute named _language_ for this tag identifies which language the description has been written in. Required feature description will be displayed during the installation process, depending on the display capacities of the device. It is recommended that devices display _at least_ the first 140 characters.

<pre><code class="xml">
 <ProvisionalAction>
 <AttributeValue>http://webinos.org/api/w3c/geolocation</AttributeValue>
 <AttributeValue>#pseudo-analysisDHP</AttributeValue>
 <DeveloperProvidedDescription language="EN">
 The geolocation feature is required by this application in order to customise search results.
 </DeveloperProvidedDescription>
 </ProvisionalAction>
</code></pre>

### Policy matching and evaluation

The policy manager of the PZP where is located the required resource must decide whether to allow or deny resource access. This decision is the result of an automated matching procedure between the application policies and the user policies.
Application policies are composed of access control policies and data handling policies.
User policies are composed of access control policies and data handling preferences.
Privacy-related allow/deny decision is the result of the matching between data subject’s data handling preferences and data controller’s data handling policies.

#### Policy matching

Policy matching is required to map an access control request onto an application and set of policies. It can be divided into three sections:

1.  XACML access control (rows 2-11 in the following example). This is the usual matching of XACML policies to application required features.
2.  PPL tags that not fall within data handling obligations. For example data handling authorization (rows 13-17 in the following example) and provisional action (rows 34-37). Matching algorithms are the same as for XACML access control.
3.  Data handling obligations (rows 18-32 in the following example). They are different from XACML obligations and require different matching algorithms.

<pre><code class="xml">
<policy>
 <target>
 <subject>
 <subject-match attr="distributor-key-fingerprint" match="[the fingerprint of the application distributor]"/>
 </subject>
 </target>
 <rule effect="prompt-blanket">
 <condition>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/geolocation"/>
 </condition>
 </rule>
 <DataHandlingPreference policyId="#pseudo-analysisDHP">
 <AuthorizationsSet>
 <AuthzUseForPurpose>
 <Purpose>http://www.w3.org/2002/01/P3Pv1/pseudo-analysis</Purpose>
 </AuthzUseForPurpose>
 </AuthorizationsSet>
 <ObligationsSet>
 <Obligation>
 <TriggersSet>
 <TriggerAtTime>
 <StartTime>
 <StartNow/>
 </StartTime>
 <MaxDelay>
 <Duration>P0Y0M7DT0H0M0S</Duration>
 </MaxDelay>
 </TriggerAtTime>
 </TriggersSet>
 <ActionDeletePersonalData/>
 </Obligation>
 </ObligationsSet>
 </DataHandlingPreference>
 <ProvisionalAction>
 <AttributeValue>http://webinos.org/api/w3c/geolocation</AttributeValue>
 <AttributeValue>#pseudo-analysisDHP</AttributeValue>
 </ProvisionalAction>
</policy>
</code></pre>

#### Obligations matching

Exact match algorithm can’t be used matching obligations. Data subject obligations (in data handling preference) and data controller obligations (in data handling policy) must be compared evaluating which obligations are more restrictive.
If data controller obligations are not less restrictive than data subject obligations, it means that data subject obligations are not violated, so there is a match.
If data controller obligations are less restrictive than data subject obligations, there is a mismatch that must be notified to the user to decide whether to send the requested data or discard the transaction.
Obligations are composed of actions (row 30 in the previous example) and triggers (rows 20-29 in the previous example), so an obligation is more restrictive if it is more restrictive in both, actions and triggers. All triggers in the preferences must be in the policy, but the policy can specify more triggers.
What "more restrictive" means depends on matching rules defined in the matching engine implementation.
For example a data handling policy ensuring data deletion is more restrictive if time specified in the _<Duration>_ tag is shorter than data handling preferences requirement (row 26). It can be more difficult to define the notion of "more restrictive" for example when the obligation require to send periodically an email to inform the user about access to his data. Notifications sent with a shorter time interval can be considered more restrictive or can be considered spam.

#### Manifests synchronization and usage

In order to allow data handling policies and data handling preferences matching when calling a remote API, the called PZP must have the application data handling policies.

Inside the Personal Zone, all manifests of all installed applications are synchronized across devices. This means that a device has all the manifests that are installed on all other devices, in order to be ready to answer to a request to that comes from the same personal zone. The synchronization of an application’s manifest is done immediately after the application’s installation. In case of installation of a newer version of an already installed application on another device the conflict is settled by separately storing different versions of the manifest.
When calling an API outside the Personal Zone, an information concerning the application manifest is attached to the call. The policy manager of the calling PZP intercepts the request, attaches the manifest information, and forwards the request to the called PZP.

Attaching manifest information does not necessarily mean that the manifest itself is attached. If the application is published on a public repository, its manifest is available and it is feasible to attach the application URI instead. This URI, allows the called policy manager of the PZP to retrieve the manifest from it.
If the application has a customized version of the manifest or if it is not available on a public accessible URI, the completed version of the manifest is sent.
On the other hand, a test application could also send a request without anything attached as a complementary information. By default this is strongly discouraged and the behavior would be to deny by default anonymous applications.

To sum up, it is possible to attach to the request:
* **_application URI_**: this is for well know applications, published on public repositories. Therefore, the manifest is available.
* **_application manifest_**: the whole manifest is attached if it is a customized version of an existing manifest, or if the application does not have a public location to post the manifest.
* **_nothing_**: just for test purposes. In this case the application is considered as _anonymous_ and default preferences would drop requests.

Below there is an example of the JSON message attachment.

<pre><code class="json">
{
 class:"URI",
 value:"http://example.org/appManifest.xml"
}
</code>
</pre>

<pre><code class="json">
{
 class:"Manifest",
 value:"<widget>…</widget>"
}
</code>
</pre>

In the followings, there are three sequence diagrams that explains synchronization and requests handling.

![]({width:1200px}Privacy-_manifests_synchronization.png)
![]({width:1200px}Privacy-_requests_across_same_personal_zone.png)
![]({width:1200px}Privacy-_requests_across_different_personal_zones.png)

||_.**Use**|_.**Language**|_.**Synchronization**|_.**Editability**|
|_policy.xml_|contains all the policies and the rules related to all APIs of the device |reduced XACML|not synchronized|editable by policy editor|
|_manifests_|contains the _feature_ tags, that specify which APIs and data the application wants to retrieve,
and the data handling policies that are a declaration statement of the application intents about gathered data|Access Control Policies: XACML-like, data handling policies: PPL tags|synchronized across the whole personal zone|not editable|

#### Example of _policy.xml_

In the following example a policy that involves a specific user, a device and targets a specific application.

<pre><code class="xml">

<policy-set combine="deny-overrides">
 <policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="id" match="appID"/>
 <subject-match attr="version" match="1.0"/>
 <subject-match attr="user-id" match="pzh.isp.com/jessica@example.com/Jessica’s+Mobile/App"/>
 </subject>
 </target>

<rule effect="deny">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://www.w3.org/ns/api-perms/contacts.read"/>
 </condition>
 </rule>

<rule effect="permit">
 […]
 </rule>

<rule effect="deny" />
 </policy>
</policy-set>
</code></pre>

Widget manifest example
-----------------------

In the example below an example concerning the widget manifest is provided.
In order to bind the data handling policies with the related obligation, a provisional action took place. If there is more than one to be binded, the _<ProvisionalActions>_ tag must be used.

<pre><code class="xml">
<widget>
 <feature name="http://webinos.org/api/w3c/geolocation" required="true" />
 <DataHandlingPolicy PolicyId="#pseudo-analysisDHP">
 <AuthorizationsSet>
 <AuthzUseForPurpose>
 <Purpose>http://www.w3.org/2002/01/P3Pv1/pseudo-analysis</Purpose>
 </AuthzUseForPurpose>
 </AuthorizationsSet>
 <ObligationsSet>
 <Obligation>
 <TriggersSet>
 <TriggerAtTime>
 <StartTime>
 <StartNow/>
 </StartTime>
 <MaxDelay>
 <Duration>P0Y0M5DT0H0M0S</Duration>
 </MaxDelay>
 </TriggerAtTime>
 </TriggersSet>
 <ActionDeletePersonalData/>
 </Obligation>
 </ObligationsSet>
 </DataHandlingPolicy>
 <ProvisionalAction>
 <AttributeValue>http://webinos.org/api/w3c/geolocation</AttributeValue>
 <AttributeValue>#pseudo-analysisDHP</AttributeValue>
 <DeveloperProvidedDescription language="EN">
 The geolocation feature is required by this application in order to customise search results.
 </DeveloperProvidedDescription>
 </ProvisionalAction>
</widget>
</code></pre>

Default policy
==============

The default policy is the policy installed with the webinos framework. This policy takes in account guidelines coming out from the 3.6 Deliverable regarding API Security Issues ([[Policy#APISI|APISI]]).

Note: Consider looking for updates in the webinos github repository before referring to the policy reported below.

<pre><code class="xml">
<policy-set combine="deny-overrides">
 <policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="class" match="b-a"/>
 </subject>
 </target>

<rule effect="prompt-blanket">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/applauncher"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/vehicle"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/devicestatus"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/geolocation"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/navigation"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/mediastream"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/mediacontent"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/app2app"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/secureelement"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/sync"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/notifications"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/remoteUI"/>
 </condition>
 </rule>

<rule effect="prompt-session">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/deviceinteraction"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/sensors"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/actuators"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/file"/>
 </condition>
 </rule>

<rule effect="prompt-oneshot">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/discovery"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/contacts"/>
 </condition>
 </rule>

<rule effect="permit">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/authentication"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/payment"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/tv"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/deviceorientation"/>
 </condition>
 </rule>

<rule effect="deny" />
 </policy>

<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="class" match="w-r"/>
 </subject>
 </target>

<rule effect="prompt-blanket">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/applauncher"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/vehicle"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/contacts.read"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/geolocation"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/navigation"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/mediastream"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/mediacontent"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/app2app"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/secureelement"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/sync"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/remoteUI"/>
 </condition>
 </rule>

<rule effect="prompt-session">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/deviceinteraction"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/sensors"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/actuators"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/file"/>
 </condition>
 </rule>

<rule effect="prompt-oneshot">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/contacts.write"/>
 </condition>
 </rule>

<rule effect="permit">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/authentication"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/payment"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/discovery"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/tv"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/widget"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/devicestatus"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/deviceorientation"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/notifications"/>
 </condition>
 </rule>

<rule effect="deny" />
 </policy>

<policy combine="first-applicable">
 <target>
 <subject>
 <subject-match attr="class" match="w-u"/>
 </subject>
 </target>

<rule effect="prompt-blanket">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/applauncher"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/geolocation"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/navigation"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/mediacontent"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/remoteUI"/>
 </condition>
 </rule>

<rule effect="prompt-session">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/deviceinteraction"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/mediastream"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/app2app"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/secureelement"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/sync"/>
 </condition>
 </rule>
 <rule effect="prompt-oneshot">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/discovery"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/sensors"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/actuators"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/widget"/>
 </condition>
 </rule>

<rule effect="permit">
 <condition combine="or">
 <resource-match attr="api-feature" match="http://webinos.org/api/authentication"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/payment"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/tv"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/devicestatus"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/w3c/deviceorientation"/>
 <resource-match attr="api-feature" match="http://webinos.org/api/notifications"/>
 </condition>
 </rule>

<rule effect="deny" />
 </policy>

</policy-set>
</code></pre>

{{include(PolicyStructure

</div>
Grammar for access control and privacy policies
===============================================

Policies could be edited by users through a graphic policy editor or manually. Manual editing must be done taking in account the grammar provided in this section in order to avoid parsing problems. The grammars presented respect the RELAX NG Compact Syntax ([[Policy#RELAXNGCS|RELAXNGCS]])

Access control policies
-----------------------

The grammar for access control policies comes from the one defined in WAC ([[Policy#WACXMLSP|WACXMLSP]]) with PPL extensions.

<pre><code class="rnc">
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
datatypes xs = "http://www.w3.org/2001/XMLSchema-datatypes"

policy-set =
 element policy-set {
 policy-set.attlist, target?, dataHandlingPreferences?, provisionalActions?, (policy-set | policy)*
 }
policy-set.attlist &=
 [ a:defaultValue = "deny-overrides" ]
 attribute combine {
 "deny-overrides" | "permit-overrides" | "first-matching-target"
 }?,
 attribute id { text }?,
 attribute description { text }?

policy = element policy { policy.attlist, target?, rule*, dataHandlingPreferences?, provisionalActions? }
policy.attlist &=
 [ a:defaultValue = "deny-overrides" ]
 attribute combine {
 "deny-overrides" | "permit-overrides" | "first-applicable"
 }?,
 attribute description { text }?,
 attribute id { text }?

dataHandlingPreferences = element dataHandlingPreferences {dataHandlingPreferences.attlist, authorizationsSet?, obligationsSet?}
dataHandlingPreferences.attlist &= attribute policyId {text}

authorizationsSet = element authorizationsSet { authzUseForPurpose* }

obligationsSet = element obligationsSet { obligation* }

obligation = element obligation { triggersSet, (actionDeletePersonalData | actionAnonymizePersonalData | actionNotifyDataSubject | actionLog | actionSecureLog)? }

triggersSet = element triggersSet { triggerAtTime*, triggerPersonalDataAccessedForPurpose*, triggerPersonalDataDeleted*, triggerDataSubjectAccess* }

triggerAtTime = element triggerAtTime { startTime , maxDelay }

startTime = element startTime { (startNow | dateAndTime)? }

startNow = element startNow { empty }

dateAndTime = element dateAndTime { text }

maxDelay = element maxDelay { duration }

duration = element duration { text }

triggerPersonalDataAccessedForPurpose = element triggerPersonalDataAccessedForPurpose { purpose*, maxDelay }

triggerPersonalDataDeleted = element triggerPersonalDataDeleted { maxDelay }

triggerDataSubjectAccess = element triggerDataSubjectAccess { accessURI }

accessURI = element accessURI { text }

actionDeletePersonalData = element actionDeletePersonalData { empty }

actionAnonymizePersonalData = element actionAnonymizePersonalData {empty}

actionNotifyDataSubject = element actionNotifyDataSubject { media, address }

media = element media { text }

address = element address { text }

actionLog = element actionLog { empty }

actionSecureLog = element actionSecureLog { empty }

authzUseForPurpose = element authzUseForPurpose { purpose* }

purpose =
 element purpose {
 "http://www.w3.org/2002/01/P3Pv1/current" |
 "http://www.w3.org/2002/01/P3Pv1/admin" |
 "http://www.w3.org/2002/01/P3Pv1/develop" |
 "http://www.w3.org/2002/01/P3Pv1/tailoring" |
 "http://www.w3.org/2002/01/P3Pv1/pseudo-analysis" |
 "http://www.w3.org/2002/01/P3Pv1/pseudo-decision" |
 "http://www.w3.org/2002/01/P3Pv1/individual-analysis" |
 "http://www.w3.org/2002/01/P3Pv1/individual-decision" |
 "http://www.w3.org/2002/01/P3Pv1/contact" |
 "http://www.w3.org/2002/01/P3Pv1/historical" |
 "http://www.w3.org/2002/01/P3Pv1/telemarketing" |
 "http://www.w3.org/2002/01/P3Pv11/account" |
 "http://www.w3.org/2002/01/P3Pv11/arts" |
 "http://www.w3.org/2002/01/P3Pv11/browsing" |
 "http://www.w3.org/2002/01/P3Pv11/charity" |
 "http://www.w3.org/2002/01/P3Pv11/communicate" |
 "http://www.w3.org/2002/01/P3Pv11/custom" |
 "http://www.w3.org/2002/01/P3Pv11/delivery" |
 "http://www.w3.org/2002/01/P3Pv11/downloads" |
 "http://www.w3.org/2002/01/P3Pv11/education" |
 "http://www.w3.org/2002/01/P3Pv11/feedback" |
 "http://www.w3.org/2002/01/P3Pv11/finmgt" |
 "http://www.w3.org/2002/01/P3Pv11/gambling" |
 "http://www.w3.org/2002/01/P3Pv11/gaming" |
 "http://www.w3.org/2002/01/P3Pv11/government" |
 "http://www.w3.org/2002/01/P3Pv11/health" |
 "http://www.w3.org/2002/01/P3Pv11/login" |
 "http://www.w3.org/2002/01/P3Pv11/marketing" |
 "http://www.w3.org/2002/01/P3Pv11/news" |
 "http://www.w3.org/2002/01/P3Pv11/payment" |
 "http://www.w3.org/2002/01/P3Pv11/sales" |
 "http://www.w3.org/2002/01/P3Pv11/search" |
 "http://www.w3.org/2002/01/P3Pv11/state" |
 "http://www.w3.org/2002/01/P3Pv11/surveys" |
 "http://www.primelife.eu/purposes/unspecified"
 }

provisionalActions = element provisionalActions { provisionalAction* }

provisionalAction = element provisionalAction { attributeValue, attributeValue }

attributeValue = element attributeValue { text }

rule = element rule { rule.attlist, condition?, dataHandlingPreferences?, provisionalActions? }
rule.attlist &=
 [ a:defaultValue = "permit" ]
 attribute effect {
 "permit"
 | "prompt-blanket"
 | "prompt-session"
 | "prompt-oneshot"
 | "deny"
 }?,
 attribute id { text }?

target = element target { target.attlist, subject+ }
target.attlist &=
 attribute id { text }?

subject = element subject { subject.attlist, subject-match+ }
subject.attlist &= empty

condition =
 element condition {
 condition.attlist,
 (condition | subject-match | resource-match | environment-match)+
 }
condition.attlist &=
 [ a:defaultValue = "and" ] attribute combine { "and" | "or" }?

match-attrs =
 attribute attr { text },
 attribute match { text }?,
 [ a:defaultValue = "glob" ]
 attribute func { "equal" | "glob" | "regexp" }?

subject-match = element subject-match { subject-match.attlist, text? }
subject-match.attlist &= match-attrs

match-model = (text | subject-attr | resource-attr | environment-attr)*

resource-match =
 element resource-match { resource-match.attlist, match-model }
resource-match.attlist &= match-attrs

environment-match =
 element environment-match { environment-match.attlist, match-model }
environment-match.attlist &= match-attrs

attr-attrs = attribute attr { text }
subject-attr = element subject-attr { subject-attr.attlist, empty }
subject-attr.attlist &= attr-attrs
resource-attr = element resource-attr { resource-attr.attlist, empty }
resource-attr.attlist &= attr-attrs
environment-attr =
 element environment-attr { environment-attr.attlist, empty }
environment-attr.attlist &= attr-attrs

start = policy-set
start |= policy
</code></pre>

References
----------

### APISI

"D036 API Security Issues":http://dev.webinos.org/redmine/projects/t3-5/wiki/D036_API_Security_Issues_Includes

### XACML

"OASIS eXtensible Access Control Markup Language (XACML) TC":http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=xacml

### PrimeLife

"PrimeLife":http://www.primelife.eu/

### PrimeLifeRDI

http://www.primelife.eu/images/stories/deliverables/d5.3.4-report_on_design_and_implementation-public.pdf

### P3P11

http://www.w3.org/TR/P3P11/

### BONDIA&S

"BONDI’s Architecture and Security Appendices":http://bondi.omtp.org/1.11/security/BONDI_Architecture_and_Security_Appendices_v1.1.pdf, January 2010

### DAPWG

"Device APIs and Policy Working Group":http://www.w3.org/2009/dap/

### RFC3986

"Uniform Resource Identifier (URI): Generic Syntax":http://www.ietf.org/rfc/rfc3986.txt, January 2005

### WACDS

"WAC Device Specifications":http://specs.wacapps.net/2.0/jun2011/index.html, June 2011

### WACSP

"WAC Core Specification section 7.5 (Security parameters)":http://specs.wacapps.net/core/#security-parameters

### WACXMLSP

"WAC: XML definition of Security Policy (RelaxNG)":http://specs.wacapps.net/2.0/jun2011/core/wacxml.rnc

### RELAXNGCS

"RELAX NG Compact Syntax":http://relaxng.org/compact-20021121.html

