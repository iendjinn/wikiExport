BEGINNING OF DELIVERABLE

Spec - Messaging
================

Conceptual Architecture
-----------------------

The event handling architecture revolves around the concept of having an "event dispatcher", that is a part of the WRT devoted to routing events among addressable entities, network interfaces and part of the non-volatile device-local storage called "Local Event Cache", where not-yet-delivered events can temporarily be stored.

Such event dispatcher is supposed to perform event routing in a very generic fashion, thus not needing to have knowledge of the specific event-based protocols in order to properly work; furthermore, it relies on the interconnect technology abstraction and NAT traversal capabilities provided by the overlay networking system to enable easy and consistent communication with the outside.

Applications are offered a low level eventing API that interfaces with the event dispatcher and allows them to send/forward events to other entities, whether local or remote, and to receive events addressed to themselves or to the addressable entities they control (e.g., a service created by the application) in a seamless way.

Higher level event-based protocols, then, can be easily defined and implemented on top of this basic architecture, possibly abstracting away details of this same architecture that are of little or no interest at an application level, thus keeping their usage as simple as it is intended to be.

![](ev_conceptual.png)

Formal Specification
--------------------

### Event object

An event is an object with the following attributes:

  ------------------------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------- ----------------------------------------------------------------------------------------------------
  **Attribute**                  **Description**                                                                                                                                                                                                             **Required**                       **Data type**
  Type                           Identifies the event type and determines payload semantics                                                                                                                                                                  Yes                                String that matches the following regular expression: [_a-zA-Z][_a-zA-Z0-9]*
  Source                         Represents the entity that originally sent the event                                                                                                                                                                        Yes                                Addressable entity object reference
  Destinations                   3 distinct sets of objects representing original destination entities, one labeled "to" (primary recipients), another labeled "cc" (secondary recipients) and the last labeled "bcc" (blind-carbon-copy recipients)   Yes                                3 distinct sets of addressable entity object references
  ID                             Event identifier                                                                                                                                                                                                            Yes                                String holding the lowercase hexadecimal digest obtained as the result of a SHA-256 hash operation
  In response to                 Reference to the event that this event is a response to                                                                                                                                                                     No                                 Event object reference
  Generation timestamp           Moment in time in which the event is generated by the original event source                                                                                                                                                 No                                 A suitable date/time representation with millisecond precision or better
  Expiry timestamp               Moment in time past which the event is no more valid or meaningful                                                                                                                                                          No                                 A suitable date/time representation with millisecond precision or better
  Delivery notification wanted   Indicates whether the sending entity wants to be notified by the receiving entities about the result of the event delivery                                                                                                  Yes                                Boolean value
  Addressing sensitive           Indicates whether the computation of the event ID should depend on the value of the "Source" attribute and the "to" set of the "Destinations" attribute                                                               Yes                                Boolean value
  Forwarding                     Addressing information on the entities involved in the last event forwarding with optional timestamp                                                                                                                        Only when the event is forwarded   An event forwarding object (described later)
  Payload                        Event type-specific data                                                                                                                                                                                                    No                                 String
  ------------------------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------- ----------------------------------------------------------------------------------------------------

### EventForwarding object

An event forwarding is an object with the following attributes:

  --------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ -------------- --------------------------------------------------------------------------
  **Attribute**   **Description**                                                                                                                                                                                                    **Required**   **Data type**
  Source          Represents the entity that forwarded the event                                                                                                                                                                     Yes            Addressable entity object reference
  Destinations    3 distinct sets of objects representing destination entities, one labeled "to" (primary recipients), another labeled "cc" (secondary recipients) and the last labeled "bcc" (blind-carbon-copy recipients)   Yes            3 distinct sets of addressable entity object references
  Timestamp       Moment in time in which the event is forwarded                                                                                                                                                                     No             A suitable date/time representation with millisecond precision or better
  --------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ -------------- --------------------------------------------------------------------------

This specification does not demand the usage of a specific serialization for transmitting events, yet it presupposes that:
* the actual serialization has a one-to-one mapping with Unicode code points for addresses and payload data;
* a one-to-one mapping between addressable entities and address strings is defined.

The event ID does not need to be transmitted, since it can be computed as the lowercase hexadecimal digest obtained by performing a SHA-256 hash on the following event object to string serialization if the "Addressing sensitive" field is specified as true:

<pre>
type|source|to-dest-1,to-dest-2,…,to-dest-n|in-response-to|generation-timestamp|expiry-timestamp|payload
</pre>

or otherwise:

<pre>
type|in-response-to|generation-timestamp|expiry-timestamp|payload
</pre>

where:
* _type_ is a copy of the string held by the Type attribute;
* _source_ is the escaped (see below) address string corresponding to the entity the "Source attribute" refers to;
* _to-dest-1_, _to-dest-2_, …, _to-dest-n_ are the escaped (see below) address strings corresponding to the entities in the "to" set of the "Destinations" attribute, sorted by ascending Unicode code points (sorting to be applied before escaping);
* _in-response-to_ is the event ID of the event that the In response to attribute refers to (lowercase hexadecimal SHA-256 digest) or the empty string if none is specified;
* _generation-timestamp_ is the string representation of the content of the Generation timestamp attribute obtained by base-10 formatting the number of milliseconds since 1970/01/01 relative to UTC or the empty string if none is specified;
* _expiry-timestamp_ is the string representation of the content of the Expiry timestamp attribute obtained by base-10 formatting the number of milliseconds since 1970/01/01 relative to UTC or the empty string if none is specified;
* _payload_ is a copy of the string held by the Payload attribute or the empty string if none is specified.

The escaped _source_ and _to-dest-x_ strings MUST be escaped so that the resulting strings are computed by applying the following substitutions in this exact order:
* each ‘' character is substituted with ’‘;
* each ’|‘ character is substituted with ’|‘;
* each ’,‘ character is substituted with ’,‘.

h3. Relationship of these objects

<div class=“uml”>(
Event **— "0.1" EventForwarding
</div>

h3. Protocol definitions

This section shortly illustrates how to define and implement event-based protocols and defines two event-based protocols that will be specially handled by the WRT.

h4. Defining event-based protocols

The event handling architecture was designed in a very generic fashion to allow the definition and implementation of custom event-based protocols with ease.

While there are several legitimate ways in which such a goal can be accomplished, in a typical scenario it should be possible to do that by:
** choosing one or more static values for the Type attribute that are unique to the protocol being defined;
* verbally defining rules that describe how protocol-specific data maps to the underlying webinos event handling system, which of its features it is legal to use (e.g., stating that events are only valid if coming from a certain kind of source w.r.t. the protocol being defined) and how protocol-specific events ought to be processed;
* defining the payload semantics;
* defining a JavaScript API that partly or completely hides away the webinos event handling system;
* developing an implementation of the defined API that makes use of the webinos Event Handling API.

h4. Delivery notifications

The delivery notification protocol is part of the core webinos event handling protocol and it provides a handful of ICMP-like functionality to the system.

A delivery notification event SHOULD be generated when an entity receives or is about to receive an event having the "Delivery notification wanted" attribute specified as true and such entity is a primary recipient among the last forwarding destinations or, if none, among original destinations, possibly according to specific policy rules. Delivery notifications MUST NOT be generated in any other case.

In order for a delivery notification event to be considered valid, the following attributes MUST be set as hereby described:

| **Attribute** | **Valid values** |
| Type | "deliveryNotification" |
| Destinations | The "to" set MUST contain only a reference to the last entity that forwarded the event because of which this notification was generated or, if none, the entity specified by the Source attribute |
| In response to | Reference to the event because of which this notification was generated |
| Delivery notification wanted | false |
| Addressing sensitive | true |
| Forwarding | unset |

The Payload attribute MUST be specfied as one of the following values:

| **Value** | **Meaning** |
| "ok" | Event successfully delivered |
| "duplicate" | An event with the same ID was already delivered to the recipient |
| "invalid" | The recipient got an invalid event (e.g., transmission error) |
| "badDestination" | The intended recipient is unknown or unreachable |
| "expired" | The event expired before the actual delivery, according to its "Expiry timestamp" attribute |
| "refused" | The event could not be received because of lack of authorization and/or policy settings |
| "noReference" | The recipient does not hold a local reference to the event specified by the "In response to" attribute |

Furthermore, in case of errors, the "Source" attribute of the event MAY indicate an entity other than the intended recipient of the original event (e.g., a "badDestination" delivery notification SHOULD NOT have the "Source" attribute indicating the unknown/unreachable recipient).

This protocol is meant to be automatically handled by the WRT without requiring any extra effort on the developer side: the Event Handling API SHALL prevent from creating events whose type is "deliveryNotification" and the WRT SHALL handle those events itself and SHALL ensure that no such events are delivered to the actual recipients.

h4. RPC

The RPC protocol provides a common event-based way of performing RPC.

It basically wraps "JSON-RPC 2.0":http://groups.google.com/group/json-rpc/web/json-rpc-2-0 objects and batches into webinos events, hence concepts, terminology, payload syntax and semantics, and behavior are meant to be aligned with that specification.

A JSON-RPC 2.0 request object or request batch is wrapped into a webinos RPC request event that, in order to be considered valid, MUST have the following attributes set as hereby described:

| **Attribute** | **Valid values** |
| Type | "JSONRPC20Request" |
| In response to | unset |
| Addressing sensitive | true |
| Forwarding | unset |
| Payload | JSON-RPC 2.0 request object or request batch |

When an entity offering RPC interfaces receives an RPC request event that does not contain a notification or a notification-only batch and said entity is a primary recipient of that event, it SHOULD generate and send an RPC response event, possibly according to specific policy rules.

Similarly to webinos RPC request events, a JSON-RPC 2.0 response object or response batch is wrapped into a webinos RPC response event that, in order to be considered valid, MUST have the following attributes set as hereby described:

| **Attribute** | **Valid values** |
| Type | "JSONRPC20Response" |
| Destination | The "to" set MUST contain only a reference to the entity specified by the "Source" attribute in the RPC request event because of which this RPC response event was generated |
| In response to | Reference to the RPC request event because of which this RPC response event was generated |
| Addressing sensitive | true |
| Forwarding | unset |
| Payload | JSON-RPC 2.0 response object or response batch |

**Note**: the JSON-RPC 2.0 specification states that notifications MUST NOT be replied to, and the same holds true for this specification; nevertheless it is still possible to use the "Delivery notification wanted" attribute to be informed about the delivery of an RPC request event, even if it contains a notification or a notification-only batch.

This protocol is meant to be automatically handled by the WRT without requiring any extra effort on the developer side: the Event Handling API and the event dispatcher SHALL prevent applications from creating and receiving events whose type is "JSONRPC20Request" or "JSONRPC20Response", while it SHALL be possible to expose RPC interfaces by describing them in the config.xml file, as specified in the Foundations section of this specification, and the WRT SHALL automatically create functions with corresponding names into the local JavaScript object that represents a discovered service, mapping calls to those functions to asynchronous RPC requests and responses operated via this protocol.

h3. Event routing

This section specifies the inner working of the webinos’ event handling mechanism at various levels, thus describing the expected behavior of the event dispatcher.

The event dispatcher basically performs four subsequent operations on each event, in the following order:
# _validation_, in which the event metadata is checked to ensure validity, well-formedness and consistency;
# _route determination_, in which the event dispatcher determines how each recipient is to be reached;
# _policy enforcement_, to ensure that local policy settings allow for the event to be further processed;
# _routing_, in which events are actually exchanged among applications, the Local Event Cache and/or network interfaces.

Event validation failure MAY result in the automatic generation and sending of delivery notification events by the WRT, if the event source (forwarding source, or, if none, original source) does not reside on the device and the event has the "Delivery notification wanted" attribute specified as true. This kind of behavior, however, is implementation-defined. Failure to validate an event SHALL prevent the event from being further processed.

In the route determination phase the event dispatcher SHALL go through the list of recipients (forwarding destinations or, if none, original destinations) and determine whether they are local or remote. In the former case, it SHALL ensure that they do actually exist and are reachable (policy settings apart) and, if this condition does not hold true, it SHOULD automatically generate and send a "badDestination" delivery notification event to the event source (forwarding source, or, if none, original source, no matter if local or remote). In the latter case it SHALL determine whether each recipient is reachable within the local networks the device is connected to or not, and also which network interface is going to be used to reach each recipient, so that this information is available in the policy enforcement phase.

Route determination for events SHALL be performed once per recipient, so that individual failures SHALL only affect one event/recipient combination. Failures during the route determination phase SHALL prevent the event from being further processed for that event/recipient combination.

Local policy rules are also implementation-defined, hence not described in this specification. Again, if the local policy prevents the event from being delivered and the event source (forwarding source, or, if none, original source) does not reside on the device and the event has the "Delivery notification wanted" attribute specified as true, a "refused" delivery notification event SHOULD be automatically generated by the WRT and sent back to the source.

Policy enforcement of events coming from remote sources SHALL be performed once per local recipient, so that individual failures SHALL only affect one event/recipient combination. Failures during the policy enforcement phase SHALL prevent the event from being further processed for that event/recipient combination.

Errors during the validation and policy enforcement phases when the event source (forwarding source, or, if none, original source) is local SHALL, instead, result in appropriate exceptions being thrown at the application-level.

#### Application-level event routing

The event handling functionality exposed to the application, at the lowest level, consists of a restricted set of conceptually simple operations: generating and sending events, or forwarding them, and registering listeners for incoming events.

This implies that the event dispatcher SHALL be able to somehow create the JavaScript representations of incoming event objects and to properly trigger the execution of the relevant listener callbacks.

Each application SHALL be allowed to handle events from/to addressable entities that it "owns" (e.g., the application itself, the services it exposes), obviously according to the constraints imposed by local policy rules and authorizations, hence it SHALL be able to both receive events directed to any addressable entity that it owns and to send/forward event on the behalf of any addressable entity it owns.

Other than that, at this level, the behavior of the system is highly dependent on the actual webinos Event Handling API specification, hence that document is to be considered the reference for determining whether a given implementation is conformant or not.

#### Device-level event routing

Each local addressable entity SHOULD be associated with some sort of buffer holding, at least, incoming event IDs, in order to limit the likelihood of receiving duplicate events. Such buffer SHOULD be managed by an algorithm that, for each incoming event:
# checks whether its event ID is already present in the buffer, in which case the event SHOULD be dropped, possibly generating and sending back "duplicate" delivery notification events;
# if the event ID is not present, instead, it is either added to the buffer if there is enough free space, otherwise an existing entry in such buffer is replaced with a new entry corresponding to the ID of the incoming event - it is recommended that the criterion by which an old entry is chosen to be replaced tends to keep inside the buffer entries corresponding to IDs of events that were received more than once.

Such algorithm SHOULD also possibly make clever use of the "Expiry Timestamp" attribute of events to keep buffer usage low.

When an event has successfully gone through validation, route determination and policy enforcement, the event dispatcher SHALL, for each local recipient:
# check if an event with the same ID was already delivered to the recipient using the incoming event buffer associated to that recipient, if available;
# create a copy of the event object for each unique local entity;
# for each event object copy:
## if the event is not a forwarded event (i.e., the "Forwarding" attribute is unspecified), remove all entities from the "bcc" set of the "Destinations" attribute that are not owned by the application by which the addressable entity is owned;
## otherwise, remove all entities from the "bcc" set of the "Forwardings" attribute that are not owned by the application by which the addressable entity is owned.
# call the relevant listeners, if any;
# possibly generate and send back "ok" delivery notification events.

#### Network-level event routing

The event dispatcher SHALL use the local PZP to receive and send/forward events from/to local networks, while it SHALL also rely on the PZH for routing events from/to entities living in remote networks.

In any case, the PZP SHALL pass events coming from the network to the event dispatcher and SHALL physically transmit outgoing events passed to it by the event dispatcher, leveraging off the overlay networking layer. This means that, according to whether the event source (forwarding source, or, if none, original source) is local or not, the eventing system will behave differently.

##### Incoming events (remote event source)

In this case the event dispatcher SHALL only try to transmit the event to local entities.

In particular, during the route determination phase, the event dispatcher SHALL:
# ensure that the event is directed to at least one local entity;
# if this is not the case:
## if the "Delivery notification wanted" attribute of the event is specified as true, it SHOULD generate and send back a "badDestination" delivery notification event;
## the event is dropped;
# otherwise the event processing SHALL proceed as described in the "Device-level routing" section, only for local destinations.

##### Outgoing events (local event source)

In this case the event dispatcher SHALL act as specified in the "Device-level routing" section w.r.t. local destinations, while for remote destinations it SHALL determine which can be reached within local networks and which reside in remote networks in the route determination phase.

Then, if the event has successfully gone through the policy enforcement phase, the event dispatcher SHALL:
# given the union of recipients in the "to" and "cc" sets of destinations that are to be reached via local networks, excluding those destinations that reside on the same device as at least one destination in the "bcc" set:
## for each involved local network:
### if the set of destinations to be reached through that network contains more than one element, the event SHOULD be preferably be transmitted through multicast/broadcast facilities, if any are available, in order to save bandwidth, with the "bcc" set unspecified;
### otherwise (only one destination or no multicast/broadcast available) the event SHALL be transmitted once per destination on that network with the "bcc" set unspecified;
# for each group of destinations specified in the "bcc" set that reside on a single device, the event SHALL be transmitted to that device, with the "bcc" set only containing that specific group of destinations;
# if there are one or more remote destinations involved, the event SHALL be transmitted to the PZH for delivery to remote entities - the data transmitted to the PZH SHALL contain a suitable serialization of the event and a supplementary list of destinations, among the event destinations, that the PZH is asked to transmit the event to.

E.g., an event has the following destinations:
* _to_: A, B, C;
* _cc_: D, E, F;
* _bcc_: G, H, I;

and:
* A and G are local;
* B and C reside on device X;
* E, H and I reside on device Y;
* D and F reside on device Z;
* device X and device Z are reached through the same local network N;
* device Y is connected to a remote network;

then, the event dispatcher will act as follows:
* A is delivered a copy of the event with empty "bcc" set, according to what is specified in the "Device-level routing" section;
* G is delivered a copy of the event with the "bcc" set only containing G, according to what is specified in the "Device-level routing" section;
* since all entities (B, C, D and F) on devices X and Z are not in the "bcc" set, and since devices X and Z are to be reached through the local network N, a copy of the event with empty "bcc" set is trasmitted to both devices using multicast/broadcast-like facilities, if available, or otherwise one copy for each device is transmitted;
* one copy of the event is sent to the PZH for delivery to the entities on the Y device, also specifying the event has to be delivered to E, H and I, with the "bcc" set containing H and I.

The actual event transmission to the "next hop" is considered as having successfully taken place when:
# if the interconnect technology is connection-aware (e.g., TCP over IP), the device has been somehow notified of the successfulness of transmission (e.g., TCP ACK).
# otherwise (e.g., UDP over IP), as soon as the whole event data has been physically transmitted.

The PZH SHALL behave in a similar fashion for the transmission of events.

#### Event caching

When the actual event transmission to one or more remote destinations fails or is not currently possible (e.g., lack of connectivity), the event SHOULD be put in the Local Event Cache by the event dispatcher to attempt later retransmission. The frequency and number of such attempts is implementation-defined.

An event inside the Local Event Cache having the "Expiry timestamp" attribute set to a moment in time in the past SHALL be removed from the Local Event Cache, NO more retransmission attempts SHALL take place and the result SHOULD be reported to the sending/forwarding entity via the Event Handling API as a delivery error.

### JavaScript APIs

The event handling functionality SHALL be available to application and third-party developers through the webinos Event Handling API.

While the API itself is quite advanced, supporting all of the current specification, a few simple examples are hereby given.

An event can be created using the webinos.events.createWebinosEvent() function, e.g.:

<pre><code class="javascript">
var evt = webinos.events.createWebinosEvent("chatMessage", {to: remoteChatApp}, "Hello!");
</code></pre>

which can then be sent using the _event_.dispatchWebinosEvent() function, e.g.:

<pre><code class="javascript">
evt.dispatchWebinosEvent();
</code></pre>

It is possible to register listeners to incoming events using the webinos.events.addWebinosEventListener() function, e.g.:

<pre><code class="javascript">
webinos.events.addWebinosEventListener(function (evt) { alert(evt.payload); }, "chatMessage");
</code></pre>

Here follows the full WebIDL interface definition:

<pre><code>module events {
 [NoInterfaceObject] interface WebinosEventEntity {
 attribute DOMString id;
 };

[NoInterfaceObject] interface WebinosEventAddressing {
 attribute WebinosEventEntity source;
 attribute WebinosEventEntity[] to;
 attribute WebinosEventEntity[] cc;
 attribute WebinosEventEntity[] bcc;
 };

[NoInterfaceObject] interface WebinosEvent {
 readonly attribute DOMString type;
 readonly attribute WebinosEventAddressing addressing;
 readonly attribute DOMString id;
 readonly attribute WebinosEvent inResponseTo;
 readonly attribute DOMTimeStamp? timeStamp;
 readonly attribute DOMTimeStamp? expiryTimeStamp;
 readonly attribute boolean addressingSensitive;
 readonly attribute WebinosEventAddressing forwarding;
 readonly attribute DOMTimeStamp? forwardingTimeStamp;
 readonly attribute DOMString? payload;

void dispatchWebinosEvent(
 in optional WebinosEventCallbacks? callbacks,
 in optional DOMTimeStamp? referenceTimeout,
 in optional boolean sync)
 raises(WebinosEventException);
 void forwardWebinosEvent(
 in WebinosEventAddressing forwarding,
 in optional boolean withTimeStamp,
 in optional WebinosEventCallbacks? callbacks,
 in optional DOMTimeStamp? referenceTimeout,
 in optional boolean sync)
 raises(WebinosEventException);
 };

exception WebinosEventException {
 unsigned short code;
 DOMString message;

const unsigned short INVALID_ARGUMENT_ERROR = 1;
 const unsigned short PERMISSION_DENIED_ERROR = 2;
 };

[NoInterfaceObject] interface WebinosEventDeliveryError {
 readonly attribute unsigned short code;
 readonly attribute DOMString message;

const unsigned short UNKNOWN_ERR = 0;
 const unsigned short INVALID = 1;
 const unsigned short BAD_DESTINATION = 2;
 const unsigned short EXPIRED = 3;
 const unsigned short REFUSED = 4;
 const unsigned short NO_REFERENCE = 5;
 };

[Callback, NoInterfaceObject] interface WebinosEventCallbacks {
 void onSending(in WebinosEvent event,
 in WebinosEventEntity recipient);
 void onCaching(in WebinosEvent event);
 void onDelivery(in WebinosEvent event,
 in WebinosEventEntity recipient);
 void onTimeout(in WebinosEvent event,
 in WebinosEventEntity recipient);
 void onError(in WebinosEvent event,
 in WebinosEventEntity recipient,
 in WebinosEventDeliveryError error);
 };

[Callback=FunctionOnly] interface WebinosEventListener {
 void handleEvent(in WebinosEvent event);
 };

[NoInterfaceObject] interface WebinosEventsInterface {
 WebinosEvent createWebinosEvent(
 in DOMString type,
 in WebinosEventAddressing addressing,
 [TreatUndefinedAs=Null]
 in optional DOMString? payload,
 in optional WebinosEvent? inResponseTo,
 in optional boolean withTimeStamp,
 in optional DOMTimeStamp? expiryTimeStamp,
 in optional boolean addressingSensitive)
 raises(WebinosEventException);
 DOMString addWebinosEventListener(
 in WebinosEventListener listener,
 [TreatUndefinedAs=Null]
 in optional DOMString? type,
 in optional WebinosEventEntity? source,
 in optional WebinosEventEntity? destination)
 raises(WebinosEventException);
 void removeWebinosEventListener(in DOMString listenerId)
 raises(WebinosEventException);
 };

[NoInterfaceObject] interface WebinosEvents {
 readonly attribute WebinosEventsInterface events;
 };

webinoscore::Webinos implements WebinosEvents;
};
</code></pre>

### Dependencies on other components

#### Overlay networking

The webinos’ event handling mechanism uses webinos’ overlay networking model to allow exchange of events on the network regardless of the underlying interconnect technology.

It is needed for the overlay networking model to provide methods to send and listen for events to/from network interfaces that do also handle the specific event serializations for each interconnect technology.

#### Policy

All communication MUST happen according to policy settings, hence policy enforcement is a fundamental part of the event handling system.

#### Authentication and Identity

The transmission of events on local and remote networks happens via the PZP and PZH components, hence involving the webinos’ authentication and identity infrastructure.

### Implementation Architecture

While this specification is relatively strict in terms of the behavior of the system, at the same time it is intended to be quite loose when it comes to suggest an implementation architecture.

This is because of two reasons: first of all, while the event handling mechanism borrows significantly from XMPP at a conceptual level, it is however pretty much a novelty, hence many real-world issues are unlikely to be foreseen at this stage; then, its actual scope of application is still to be investigated, also because no performance constraints were explicitly specified beforehand.

This section discusses some of the most crucial implementation choices, also based on some experience gained by developing a small prototype implementation, however with no claim of exhaustiveness.

#### Event dispatcher and PZP

The event dispatcher unit described in this specification is a logical abstraction that does not necessarily need to be implemented as a single component and it shows significant functionality overlap with the PZP component.

One possibility might be, indeed, to actually let the PZP implement most of the event dispatcher functionality. However, such a choice has a number of implications:
* if the PZP lives in a separate thread or process w.r.t. the web application, it would be probably impossible to avoid blocking synchronization (e.g., local policy enforcement always happens synchronously), thus introducing new sources of unpredictable delays, and also, if living in a separate process, each event might need to be validated twice for security reasons (e.g., once by the API implementation running in the web application context, then by the PZP process) - in practice, anyway, even though not ideal, the result might prove to be "good enough", at least for a first implementation phase;
* the PZP may get slower at processing requests, on average, especially if a one-main-loop design is used (e.g., while an event is being processed, all other requests are "frozen");
* since the PZP is a security-critical component, the dispatcher functionality would need to be somehow isolated from the rest of the PZP, thus probably making things a lot more complicated and likely to turn "normal bugs" into serious vulnerabilities, depending on the level of isolation.

Another possibility could consist in having a part that translates event-related requests into more basic lower-level requests for the PZP and/or other components from within the web application context, thus letting the PZP to handle smaller and simpler requests. While such a solution could solve or mitigate the problems above, it might potentially introduce new ones:
* it could be needed to perform policy enforcement both from within the web application context and inside the PZP, thus potentially introducing policy synchronization issues;
* while such an approach should theoretically reduce average latency, it might however have significant impact on average throughput due to synchronization overhead (smaller but more frequent requests to the PZP than before).

#### IPC and synchronization issues

At a device-level, data exchanges among web applications might happen by just sharing memory references if the involved applications live within the same process. This is, however, not always the case, and also it is very likely that we need process separation in any case for security and reliability reasons, hence we will concentrate on a multi-process scenario here.

Typically, native APIs that allow to control/manipulate JavaScript execution (e.g., NPAPI, Webkit’s JavaScriptCore), provide means to add hooks into the JavaScript processing loop (or, otherwise, main GUI loop), from which it is possible to safely perform JavaScript-related work for a web page. While this allows to, e.g., create JavaScript event objects, the actual data transfer from the sender to the receiver(s) does still need to be performed using some IPC mechanism.

Of the many viable alternatives for IPC, two seem the most appropriate for the taks: Unix domain sockets (or roughly equivalent, named pipes on Windows) and shared memory.

In a few words, Unix domain sockets should make the implementation task a lot easier, also probably leading to less interoperability- and extensibility-related headaches, but on the other hand they might have serious performance implications. An approach based on shared memory, instead, would be much more challenging to be developed, especially w.r.t. security, memory usage and synchronization issues, but would probably lead to a faster and much more responsive system behavior.

The advice, here, is to first make an attempt with Unix domain sockets (or named pipes on Windows) and, in case it turns out that IPC constitutes a major performance bottleneck, to switch to either shared memory or to a hybrid approach of some kind.

#### JavaScript-related issues

There is a number of JavaScript-related issues that should be taken into account when developing an implementation.

First and foremost, JavaScript is a garbage collected language, and, as of now, typical JavaScript engines do not offer a native API to control this mechanism. This means that it is basically impossible to limit the performance unpredictability due to garbage collection, hence performing time-critical tasks (e.g., soft real-time tasks like real-time DSP) can be actually considered outside of the scope of the language.

This consideration alone gives us a first hint on scope of the event handling system itself, since it is mainly meant to be used by JavaScript applications and libraries through the Event Handling API. Indeed, measurements on our prototype implementation show that the generation and local transmission of a simple event might take from less than 1 ms up to 500 ms.

Furthermore, the need to prevent garbage collection of event objects when they are sent/forwarded, together with "In response to" object references and the overall asynchronous nature of the system might lead to significant memory consumption. It is, therefore, recommended that this particular issue is taken very seriously by implementors.

END OF DELIVERABLE

Ideas for phase 2
-----------------

### Delivery notification protocol

Possible additions:
| **Value** | **Meaning** |
| "redirect xyz" | Event redirected to entity with address xyz, further communication should be done with that entity |
| "cached" | Event temporarily cached (e.g., destination is an application that is about to be started) |

With such additions it would be possible to receive multiple delivery notifications for a single event.

### RPC protocol

I do suggest to reconsider the current config.xml configuration since on one hand it simplifies some things from the server provider POV, but actually makes it needlessly more complicated to have more P2P-ish applications where both ends are at the same time are users and providers.

Furthermore, pub/sub described below cannot be properly done without allowing dynamic creation/destruction of services (encapsulation would defeat the purpose of having event IDs).

### Publication/subscription protocol

Publication/subscription works by having "nodes", that are entities holding collections of events, to which other entities, including other nodes, can publish or subscribe to.

Four kinds of actors are involved in the usage of a node:

  ------------ ----------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------
  **Actor**    **Cardinality**   **Description**
  Provider     1                 The entity that logically manages the storage of the node and that "runs" it (i.e., receives and sends/forwards events from/to other involved actors)
  Owner        1                 The entity that manages the lifecycle of the node and its configuration, including publication/subscription policy
  Publisher    Any               An entity that is allowed to publish content to the node
  Subscriber   Any               An entity that receives updates regarding the node content
  ------------ ----------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------

Furthermore, nodes SHALL also be associated with node-specific configuration that is managed as a set of key/value pairs. Such configuration MUST include at least the following pairs:

  ------------------------ ------------------------------------------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------
  **Key**                  **Description**                                                                             **Valid values**
  discoveryPolicy          Specifies the constraints under which entities are allowed to discover the node             _TBD (a suitable policy representation - we probably need: public, hidden, device-local, user-only, what else?)_
  publicationPolicy        Specifies the constraints under which entities are allowed to become node publishers        _TBD (a suitable policy representation - we probably need: public, owner-only, device-local, whitelist/blacklist, what else?)_
  subscriptionPolicy       Specifies the constraints under which entities are allowed to subscribe to the node         _TBD (a suitable policy representation - we probably need: public, device-local, whitelist/blacklist, what else?)_
  getConfigurationPolicy   Specifies the constraints under which entities are allowed to get the node configuration    _TBD (a suitable policy representation - this is more complicated, as we might need to define who can have access to what)_
  getPublishersPolicy      Specifies the constraints under which entities are allowed to get the list of publishers    _TBD (a suitable policy representation)_
  getSubscribersPolicy     Specifies the constraints under which entities are allowed to get the list of subscribers   _TBD (a suitable policy representation)_
  ------------------------ ------------------------------------------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------

and MAY optionally include other key/value pairs with arbitrary semantics, thus allowing for extensibility of this protocol in that regard.

The semantics of optional pairs that all implementations MUST support is hereby specified:

  --------------------- -------------------------------------------------------------------------------------------- ------------------
  **Key**               **Description**                                                                              **Valid values**
  title                 Short human-readable name for the node                                                       Any string
  description           Human-readable description for the node                                                      Any string
  _others?_   _XMPP PubSub spec implicitly defines: creator, creation date, language, contact_   ?
  --------------------- -------------------------------------------------------------------------------------------- ------------------

Entities that act as node providers SHALL expose RPC methods to:
* discover nodes;
* request publish authorization to a node;
* request subscription to a node (optional parameter: event type(s) of interest);
* get the list of publishers to a node;
* get the list of subscribers to a node;
* get configuration key/value pairs for a node;
* (for wannabe-owners only) get default node configuration;
* (for wannabe-owners only) create a node, possibly specifying configuration key/value pairs to request non-default configuration;
* (for owners only) destroy a node;
* (for owners only) set configuration key/value pairs for a node;
* (for owners only) modify the list of publishers to a node;
* (for owners only) modify the list of subscribers to a node.

The basic idea is that when a publisher publishes content to a node, the provider entity SHALL try to transmit it to all subscribers of that node interested to that event type. In other words, publication/subscription nodes represent a further level of indirection used to transmit data to "interested and authorized entities" without specifying them explicitly.

When a node is up and running, it SHALL listen to events from authorized publishers. Upon successful reception of an event from an authorized publisher, the provider entity SHALL try to transmit it to interested subscribers according to the following rules:
* if the event has the "Addressing sensitive" attribute specified as true, the provider SHALL forward the event to each interested subscriber, one by one (so that they don’t get references to each other);
* otherwise the provider SHALL generate new events that are identical to the one it received, except that the "Source" attribute shall reference the node itself and the "to" set of the "Destination" attribute SHALL only contain a reference to the interested subscriber that the event is being sent to (i.e., a new event is generated for each subscriber) - the "cc" and "bcc" sets of the "Destination" attribute MAY be used freely by the provider.

Publication/subscription nodes may be themselves publishers or subscribers to other nodes; this provides a conceptually simple mean to do collection and/or forwarding of events in a more complicated fashion than with single nodes. The potential harm of creating loops is likely to be mitigated by proper implementation of the input event ID buffering mechanism.

### User-visible notifications protocol

(This is seriously outdated, but you get the idea)

Notification messages can be of two kinds: notification requests and notification responses.

#### Notification requests

Notification requests have the type field set to _<TO BE DECIDED>_, can only be directed to users and have **mandatory** payload consisting of the JSON serialization of a notification object.

A notification object MUST contain:

  --------- -------------------------------------------------------------------- -------------------
  Field     Description                                                          JS representation
  Summary   Single line overview of the notification (e.g., "You have mail")   string
  --------- -------------------------------------------------------------------- -------------------

and MAY contain:

  -------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------------------------
  Field                Description                                                                                                                                                                                                                                                                                                             JS representation
  Replaces ID          Event ID of an existing notification that this notification is intended to replace (this also serves to cancel a previous notifications involving user interaction)                                                                                                                                                     hash string
  Urgency level        Integer value that specifies the notification urgency (0 = low, 1 = normal, 2 = critical)                                                                                                                                                                                                                               constant integer numeric value
  Category             URI that indicates the notification type                                                                                                                                                                                                                                                                                URI string
  Icon                 URI that points to the icon file or that embeds image data (using the "data:" URI scheme)                                                                                                                                                                                                                             URI string
  Body                 Longer notification text                                                                                                                                                                                                                                                                                                string containing HTML markup
  Actions              Keyword/description pairs of actions the user can choose, where the keyword is a string that identifies the action and the description is the string that is displayed to the user - there MUST always be a default action identified by keyword "default" and keywords MUST be unique within a notification object   associative array of keyword/description mappings
  Expiration timeout   number of milliseconds since the display of the notification at which the notification should automatically close                                                                                                                                                                                                       numeric value
  -------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------------------------

> Stefano/ISMB: should add human-readable name of the sender?

> Stefano/ISMB: Rationales:
> * URIs for category: possibility to automatically get metadata for unknown categories in the future (e.g., RDF data from the specified URI);
> * URIs for icons: known URIs will correspond to cached/stored icons - no need to retrieve them again (it should be ok for theming too, the URI points to the default icon, a local setting overrides that), while unknown non-data URIs point to an image that can be just downloaded.

The WRT is responsible for the handling and visualization of incoming notifications.

> Stefano/ISMB: a (privileged?) API may be offered to intercept, interact and/or replace the WRT notification system…

The urgency level parameter does also give an indication on whether a notification SHOULD be somehow logged/remembered (by default, it should be the case if it is "normal" or "critical") or not.

> Stefano/ISMB: deliberate vagueness here.

#### Notification responses

Notification responses have the type field set to _<TO BE DECIDED>_, can only be coming from users and have **mandatory** payload consisting of just the chosen action keyword and **mandatory** "In response to" field set to the original notification request identifier.

Such events SHALL always have the entity that sent the original notification as the primary recipient and the receiving user as secondary recipient, so that all devices owned by the user become aware of the fact that a response was given (e.g., they can close the notification).

Normally, responses to notification requests that are somehow logged/remembered (e.g., having "normal" or "critical" as urgency level) SHOULD be logged/remembered as well.

### Other misc ideas

-   allow explicit usage of local broadcast/multicast facilities (suggested by Dave/W3C);
-   look into device coordination issues (suggested by Dave/W3C).

