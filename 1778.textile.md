Spec - Discovery
================

Conceptual Architecture
-----------------------

Webinos discovery defines interfaces to detect devices and services either through remote network access or via short range connections (e.g Bluetooth, WiFi) or local bearers such as USB. It is responsible for:

-   Advertising or publishing device/serviceâ€™s availability and capability
-   Querying or finding device/service based on certain criteria
-   Binding with device/services that meets the searching requirement
-   Discovering PZH

In remote scenario, discovery aspect happens after connecting with Personal Zone Hub (PZH). Typical steps in remote discovery:
* Publish presence information to PZH along with services and publish/subscribe information.
* Gather service information based on userid/jabberid
* Establish connection with other nodes

Facing the challenges of a wide variety of discovery protocols used these days due to multiplicity of networking technology, Webinos discovery proposes a solution by providing two levels of APIs:
* Low level APIs based on specific interconnecting technologies for 3rd party developers
* High level generic APIs using Javascript libraries for web developers.

Technical Use Cases
-------------------

### Assumptions:

-   No particular device is considered, it could be mobile or TV or automobile or PC
-   There could be more than one owner for the same device (e.g. TV)
-   Connectivity happens seamlessly for both local and remote discovery. In case of remote device connection to local device which does not run on IP, PZP will act as a bridging point.
-   Policy management and security mechanism apply while connecting and in some cases after connecting.
-   Local discovery applies for finding USB, BT, WiFi, UPnP and ZeroConf devices
-   In technical scenario, Personal Hub could be XMPP server. XMPP is used for connecting to server and gathering information about connected devices. It does not support discovery directly but provides information about connected devices.
-   All communication happen over IP for remote discovery, IP addresses are assigned through DHCP, if not they are assigned based on link local address. In local discovery it could be IP based or non IP based for short range bearer devices.
-   PZH is assumed to be in cloud and PZP will act in case of PZH missing, as it has cached information about the devices.

### Use Case 1:

George wants to access his own device located remotely on public IP.

##### Description:

George is travelling and wants to access his home TV or set top box to access the content on the device. Based on the selection of device, a connection is established and real time communication takes place between devices. This would involve establishing transport layer security, exchanging user credentials with personal hub. If personal hub indicates device is online, connection is established between the devices. Identification of device happens through JID (Jabber ID) used in XMPP protocol. Usage of protocol is described in "Protocol Description":http://dev.webinos.org/redmine/projects/wp3-1/wiki/Spec_-_Discovery#Formal-Specification

h5. Main challenges:

* Find own device and establish secure communication over device.
* Know about the presence of the device and if it is available to be used.

h3. Sequence Diagram- Use Case 1

<div class="uml">
actor George<br/>
autonumber<br/>
George -> George_Device:Discover Device<br/>
George_Device->Personal_Zone_Proxy:Discover Device X<br/>
Personal_Zone_Proxy->Personal_Hub:Discover Device X<br/>

alt device searched is under same Personal_Hub<br/>
 Personal_Hub --> Personal_Zone_Proxy:Resource Information<br/>
 Personal_Zone_Proxy --> George_Device:Resource Information<br/>
else device searched is under different Personal_Hub<br/>
 Personal_Hub -> Personal_Hub_X:Find resource based on JID<br/>
 Personal_Hub_X --> Personal_Hub:Resolved connection information<br/>
 Personal_Hub --> Personal_Zone_Proxy:Resource Information<br/>
 Personal_Zone_Proxy --> George_Device:Resource Information<br/>
end<br/>

George_Device -> Device_X: Start XMPP Stream Message<br/>
Device_X -> George_Device: Return stream features and id<br/>

alt check for TLS<br/>
 George_Device -> Device_X: Establish TLS connection<br/>
 Device_X-->George_Device: Proceed<br/>
end<br/>

alt check fro SASL mechanim<br/>
 George_Device -> Device_X: Exchange Authentication mechanism and Id or else exchange challenges<br/>
 Device_X -->George_Device: Succeed<br/>
end<br/>

alt check for bind<br/>
 George_Device -> Device_X : Send bind message for specific resource<br/>
 Device_X--> George_Device : Bind JID<br/>
end<br/>

George_Device -> Device_X : Presence/Roster/Message information exchange<br/>

</div>
### Use Case 2:

George wants to access device located locally using link local address.

##### Description:

George is at home and wants to access TV from his mobile phone. User has to first select the discovery mechanism he wants to use; he could either use all or use a specific device to find other devices.

##### Main challenge:

-   Identify device from set of device and authenticating to access device
-   If device is being shared, what policy rules apply regarding access? Which user owns the device?

### Sequence diagram - Use Case 2

<div class="uml">
actor George
autonumber
George->George_Device: Search device based on discovery mechanism
note over George
 all mechanism could be used or one specific mechanism could be used
end note
George_Device-->George: List of devices depending on interfaces/discovery
George -> George_Device: Select mechanism and retrieve list of devices
George_Device --> George: List of devices available based on mechanism
note over George
 In discovered device list, filtering of George device is needed.
end note
George -> George_Device: Select Device to connect
George_Device--> George: Device connected

</div>
#### Use Case 3:

Paul wants to access his friend George’s device and connectivity is using public IP.

##### Description:

Paul has his friendâ€™s id which in XMPP terms would jabberid@domain and wants to connect with a particular device. Information about the George’s device that are online has to be first retrieved if Pauls’s device does not have information and then connection is established based on George’s permission to access device functionality. To support connection it would involve communication between PZH and PZP. It is assumed in this Use Case, PZP in Paul Device itself does not have George’s PZP availability.

Here it is assumed that PZP holds information about local devices such as USB and BT. Consider PZP to be MP, USB and BT are local but having this information is not available to PZH directly, it is not possible since they are not IP based and cannot be updated about their availability. PZP will act as a bridge to update information. In the example, when PZP is coming online, it includes information about local devices to it. If there are other BT device all in near proximity it is PZP that updates PZH about them. So when device comes online, it is through PZH, PZP will be able to obtain information.

##### Main Challenge

1.  Policy rule to allow what features to be accessible to other user devices
2.  Authentication before connecting two devices

### Sequence Diagram - Use Case 3

<div class="uml">

actor Paul
autonumber
alt George Device Information is not available in Paul’s PZP
Paul -> Paul_Device: Fetch George Device Information
note over Paul_Device
 Includes information about devices that are online
end note
Paul_Device->Paul_PersonalZone_Proxy: Forward request
Paul_PersonalZone_Proxy->Paul_PersonalHub: Forward Request
Paul_PersonalHub ->George_PersonalHub: Server communication
George_PersonalHub->George_PersonalZone_Proxy: Resources information
George_PersonalZone_Proxy-->George_PersonalHub: Forward online device list
George_PersonalHub-->Paul_PersonalHub: Forward online device list
Paul_PersonalHub-->Paul_PersonalZone_Proxy: Forward online device list
Paul_PersonalZone_Proxy-->Paul: Present online device list
Paul -> Paul_Device: Select a device to connect
Paul_Device -> Paul_PersonalHub: Connect to George device
Paul_PersonalHub -> George_PersonalHub: Connect(policy/authentication)
George_PersonalHub -> George: Ask for permission to allow
George -> Paul_Device: Grant Permission and allow connection
end

</div>
### Use Case 4:

Paul wants to access George device using local link local address or local address assigned using DHCP

##### Description

Paul is visiting his friendâ€™s house and wants to show movie on his phone on George TV. In order to do that Paul has to first authenticate with Georgeâ€™s personal hub, once authenticated Paul should be able to establish connection with Georgeâ€™s TV based on policies of George.

##### Main Challenge

1.  Policy setting and at the same time ease in using setting to allow and stop communication with friend device
2.  Paul if he is a family member and wants to access George device, how to handle access all the time
3.  In absence of personal hub, how to impose policies and authentication

### Sequence Diagram - Use Case 4

<div class="uml">
actor Paul
autonumber
Paul->Paul_PZP: Search George Device
alt if Paul can connect to his PZH
 Paul_PZP->Paul_PZH: Authenticate with user credentials
 Paul_PZH --> Paul_PZP: Features and mechanism supported
 Paul_PZP->Paul_PZH: Complete XMPP connection
 Paul_PZH--> Paul_PZP: Bind id
 Paul_PZP-> Paul_PZH: Service discovery for George resources
 Paul_PZH->George_PZH: Service discovery for George resources
 George_PZH--> Paul_PZH: Service available and if items requested its information too
 Paul_PZH-> Paul_PZP: George resource and items information
 Paul_PZP-->Paul: Present George device details
else if Paul has access only to local network
 Paul_PZP-> Local_Discovery: Local devices
 Local_Discovery--> Paul_PZP: Result of devices located in range
end
Paul->Paul_PZP: Select device to connect with
Paul_PZP->Paul_PZH: Connect with George device
Paul_PZH->George_PZH: Connect with George device
Paul_PZP->George_PZP: Stream movie

</div>
Formal Specification
--------------------

This section covers both high level and low level API for web developer and third party interface developer respectively.

### Protocol definitions

This section highlights protocol, data structure that third party developer could use to implement webinos discovery module.

This section provides outline specifications for device and service discovery module. Device discovery aspect is not limited to just one protocol but provides support for discovery on more than one interface and allows usage of more than one discovery mechanism.

Discovery module aims to provide wrapper interface for high level API and low level discovery specific API. It will provide a uniform interface for web developers to obtain addressing information on devices and services across a wide range of interconnecting technologies. The discovery module shall provide the following functionalities:

-   Advertise or publish device/serviceâ€™s availability and capability
-   Query or find device/service based on certain criteria
-   Bind with device/services that meet the searching requirement

To describe above functionalities below section covers data structure and functional methods for discovery mechanism. All aspects covered below differ for local and remote discovery mechanism.

*Note: Webinos will provide information about interfaces based on BT and WLAN. Discovering WiFi/BT devices and connecting to such devices is outside scope of webinos and is underlying OS functionality. Assigning IP address after connection establishment is also underlying OS functionality. Though webinos can provide these functionalities but it will be a replication of functionality.*

#### Advertising/Publishing Information

Devices advertise their services and allow other devices to discover device’s service. Each discovery mechanism has different way of advertising services and allow communication establishment with the device. Mechanism of advertising differs in local discovery and remote discovery.

In local discovery mechanism, service availability/publishing has to be multicast and discovery happens by looking for a service and establishing communication with the device based on the service details. In remote discovery, connection is established with PZH and then information is exchanged to discover other devices.

##### Local Discovery

The interface that will be provided to search local device in webinos will be USB. WiFi and BT device discovery as mentioned above will be discovered and connected through underlying OS. Support to retrieve information about connection to such interfaces will be supported.

Reason for including USB is to find all devices that are connected to a device to be searchable and allow remote device to connect to the device, for usage through USB over IP.

All interfaces are to be handled as resource and should be separately addressable for remote device to discover it.

Device needs to advertise about the service it offers using ZeroConf or UPnP. This advertisement provides information about capabilities of the device and the information to establish communication with the device.

<pre><code class="c">
#define MAC_LEN 6

// Discovery structure searches for device based on interface and discovery mechanism
// Note it is not needed to use all mechanism all the time, it is user configurable option.
struct discovery{

// List of USB connected interfaces
 USB *usb;

// Holds list of printers found through SLP
 SLP *slp;

// Devices published/advertised information as well as device found through ZeroConf resolve method
 ZeroConf *zero_conf;

// UPnP device discovered list
 UPNP *upnp;

// DLNA discovered device list
 DLNA *dlna;
};

// UPNP based devices found are hold in this structure
typedef struct _UPNP{

// Unique id of the device
 char *uuid;

// Device type along with manufacturer details
 char *device_type;

// Address of device
 char *address;

// Port on which service is available
 int port;

// Description of service
 char *description;

// Holds another UPnP discovered device
 struct _UPNP *next;
}UPNP;

// Discover printers based on SLP
typedef struct _SLP{

// Service type
 char *srvtype;

// Service URL
 char *srvurl;

// TO hold other SLP discovered devices
 struct _SLP *next;
}SLP;

// Structure to hold ZeroConf information
typedef struct _ZeroConf{

// Publish device details, this is first step to be done since devices need to start service before publishing service
 ZeroConf_Publish *publish;

// Discovered ZeroConf based device details
 ZeroConf_Resolve *resolve;
}ZeroConf;

// This structure holds information that will be used for publishing service for webinos based device
typedef struct _ZeroConf_Publish{

// Name of the device such as hostname@machinename
 char *name;

// Port on which service will be available
 int port;

// Advertised service type such as _presence._tcp
 char **service_type;

 // TXT in form of pair (type=value)
 char***txt;
}ZeroConf_Publish;

// This structure holds information of ZeroConf device available in the network
typedef struct _ZeroConf_Resolve{

// user assigned name or default name
 char *name;

// service name of the type we are connecting to
 char *type;

// human friendly service description
 char *nice;

// numeric network interface index
 char *iface;

// true => IPv6, false => IPv4
 bool ipv6;

// IP address
 char *address;

// Port on which service is running
 int port;

// additional name/value pairs
 char *txt;

// Holds next ZeroConf Resolve data;
 struct _ZeroConf_Resolve *next;

}ZeroConf_Resolve;

// This struct will hold information about searched USB devices
typedef struct _USB{
 // Unique product number of USB device
 unsigned long product_number;

// Vendor/Manufacturer id
 unsigned long vendor_id;

//USB standard defined class of device
 unsigned long device_class;

// Each device class is divided into multiple device sub class
 unsigned long device_sub_class;

// Device number
 unsigned long device_num;

// Bus on which device is running
 unsigned long bus_num;

// Text description of the vendor name
 char *vendor_name;

// Hold details of next USB device
 struct _USB *next;
}USB;

</code></pre>

Devices searched are presented to the user and once user selects device to connect with, a bind operation is performed on the device.

#### Bind

Bind operation differs on if action is local or remote. In case of remote it will involve communication iwht PZH.

##### Local Device Bind

Each interface defines different bind mechanism. If binding is based on interface, device will be connected to selected interface. In typical socket communication it would be based getting information based on getaddrinfo/getifaddrd. Once information is retrieved, a socket connection is established.

<pre><code class="c">
struct device_bind
{
 // protocol type
 unsigned char protocol;

// interface
 unsigned char iface;

// host name of the device
 char *hostname;

// IPv6 address
 unsigned char ipv6[16];

// IPv4 address
 unsigned char ipv4[14];

// port number to connect or the port that will be used if acting as server. This could be user input or random input
 int port;

// MAC addr of the interface, if USB product:vendorid, rest filled with Zero
 char mac_addr[MAC_LEN];
}LocalConn;

// 1 if successful or if any error depends on iface and socket error

int connect_local(LocalConn **local);
</code></pre>

h4. Remote Discovery

Remote discovery happens after connecting with PZH. The PZH is resolved based on a domain name, it involves using of DNS-SRV resolution mechanism, to fetch address information and establish socket communication with PZH. The information needed from user is userid along with domain name, resource (optional), and password. Based on this information connection will be established with PZH. User can discover other users and their devices and establish communication with the resources.

There are several mechanisms that supports remote discovery, it can be done through resource distributed as distributed hash tables or using XMPP. To communicate with remote device, it requires having IP address or domain information to establish socket communication with the device. First step is to gather address information.

XMPP is used for remote discovery in Phase 1, as it allows connecting with different resources, finding services, finding different items of his own and user friends. For example, userid alice@example.org/camera has alice as a userid, example.org is the domain that holds information about user alice and camera is the resource that user wants to connect. Using same id but with different resource, user can connect to XMPP server, alice@example.org/phone.

A typical XMPP node can hold three pieces of information:
** Resource/Nodes: Entity that can be addressed
* Services: Commands or function resource can use
* Items: These are nodes under a Resource.

To perform service discovery of user own devices or other user devices, XMPP Service Discovery (XEP-030) will be used. It defines protocol mechanism to retrieve information about info-nodes and items-node associated with a jid. Info-nodes are similar to full jid (alice@example.org/camera) and item-nodes are not addressable directly, the information about them is retrieved using info-nodes. Query tag of XMPP messages supports both items and info node. Message exchanged uses type get and result between requesting and sending entity respectively. See below diagram for full call flow.

In a personal zone, not all devices will be IP capable. To handle this scenario a device can include all the local devices connected to it (e.g. bluetooth, usb) as items-node. Any device searching for George devices will first fetch information about info-nodes and then each info-nodes can then be queried to get all items-node information.

As part of discovery, services have to be discoverable. After XMPP connection has been established, it could fetch service information based on URI mechanism or using adhoc command functionality, where a particular node holds information about advertise service. Both mechanism are supported in XMPP.

The bridging mechanism between local devices and remote devices will be a functionality provided by webinos’s PZP. As each node cannot be directly communicable they will be first communicated to Personal Zone Proxy (PZP) and then PZP will act as a mediator between devices. The communication mechanism is dependent on how services are defined. This could be either based on adhoc commands or based on config.xml defining services.

Next step is finding information about devices whether they are online. User can add different user he knows in a roster (XMPP terminology for friend list) and can define different groups. Depending on presence preference, roster information will be updated once friend and his devices are online. All the information displayed will be based on policy management rules.

User should be able to get all the resources that belong to him indicated as devices in his personal zone. All devices of the user will be listed as resources/info-nodes. It should be guaranteed that each resource is unique. Once the user select device he wants to connect, depending on the preference connection will be established.

<div class="uml">

actor George
autonumber
George -> George_Device: Locate device "set-top-box"

alt Device is coming online (for the first time/or connecting back to Personal Hub/XMPP_Server)
 George -> George_Device: Declare device as selfbot, enter username and password.

note over George_Device
 Resource information could be user entered as string or can be automatically generated
 end note

George_Device->DNS_Server: DNS Resolv mechanism based on domain

note over DNS_Server
 Typical functional call to resolve domain information:
 1) res_query("_xmpp-client._tcp.domain", C_IN, T_SRV, resolve, sizeof resolve) // domain in this george@jabber.org is jabber.org
 2) ns_initparse(resolve.buf, len, handle); // Initialize parse to resolve information
 3) ns_parserr(&handle, section, num, &res) // Gets the res field which contains information about service.
 4) ns_rr_type(res) == ns_t_srv // Interested only in service record
 5) ns_rr_rdata(res) // result is of form: prio|weight|port|target
 end note

George_Device->XMPP_Server: Connect using IP address and port information retrieved
 XMPP_Server--> George_Device: Connection established

George_Device->XMPP_Server: Stream Initial Message

note over XMPP_Server
 <stream:stream from = ‘george@jabber.org’ to = ‘jabber.org’ xmlns=‘jabber:client’ xmlns:stream=‘’>
 end note

 XMPP_Server --> George_Device: Stream Response with feature information

 note over George_Device
 <stream:stream from = ’jabber.org’ to = ’george@jabber.org’ id =’UNIQUE ID’ xmlns=’jabber:client’ xmlns:stream=’’>
 <stream:features><mechanisms> <mechanism> </mechanism> </mechanisms> <bind/> <session/> <starttls><required/></starttls></stream:features>
 end note

 alt depending on stream features TLS and SASL message exchange might be required
 George_Device->XMPP_Server: <starttls xmlns=’urn:ietf:params:xml:ns:xmpp-tls’/>
 XMPP_Server-->George_Device: <proceed/>

 note over George_Device
 Initialize SSL mechanism to establish TLS communication; using openssl following list of functions if called will established SSL Connection:
 1) SSL_CTX_new(SSLv23_client_method()); SSL_CTX _set_client_cert_cb(); SSL_CTX_set_mode(); SSL_CTX_set_verify();SSL_new;
 2) Establishes TLS connection: SSL_Connect(); select(sock)
 end note

 George_Device->XMPP_Server: Stream Initial Message
 George_Device->XMPP_Server: SASL mechanism based on Stream features

 note over George_Device
 Each XMPP server supports multiple mechanisms, we will take example of PLAIN mechanism (min requirement is DIGEST-MD5)
 1) generate authid by base64("0username0password")
 2) <auth xmlns=’urn:ietf:params:xml:ns:xmpp-sasl’ mechanism=‘PLAIN’> authid </auth>
 end note

XMPP_Server-->George_Device: <success/>

George_Device -> XMPP_Server: Bind with resource

note over XMPP_Server
 <iq type=‘set’ id=‘bind_id’ > <bind xmlns=‘urn:ietf:params:xml:ns:xmpp-bind’><resource> </resource></bind></iq>
 end note

XMPP_Server --> George_Device: Bind Success with id

 end
end

George_Device->XMPP_Server: Send Presence Information

note over XMPP_Server
 <presence from=’george@jabber.org/set-top-box’ xmlns=’jabber:client’> <c xmlns=’http://jabber.org/protocol/caps’> </presence>
end note

XMPP_Server-->George_Device: Retrieve set-top-box status

note over George_Device
 <iq xmlns=‘jabber:client’ type=‘get’ id=‘msg_id’ to=‘george@jabber.org/set-top-box’ from=‘jabber.org’><query xmlns=‘http://jabber.org/protocol/disco#info’/></iq>
end note

George_Device-> XMPP_Server: Send node information

note over XMPP_Server
 <iq from=‘george@jabber.org/set-top-box’ id=‘msg_id’ to=‘jabber.org’ type=‘result’ xmlns=‘jabber:client’>
 <query xmlns=‘http://jabber.org/protocol.disco#info’> <identity category=‘client’ name=‘webinos’ type=‘self-bot’/>
 <feature var=‘http://jabber.org/protocol/caps’/> <feature var=‘http://jabber.org/protocol/disco#info’/>
 <feature var=‘http://jabber.org/protocol/commands’/> </query> </iq>
end note

</div>
Other XMPP mechanism that is relevant for webinos is using it in serverless environment i.e. lack of PZH with no public ip connection possible. XMPP Serverless Messaging (XEP-0174) uses ZeroConf as underlying discovery mechanism. It provides information for two devices to establish socket connection, and once socket connection is established it uses XMPP streams and iq message to exchange messages between devices. Devices can extend stream message exchange by performing feature exchange and authenticate with each other before receiving messages.

XMPP defines ZeroConf service type "_presence._tcp" and requires information about specific port and IP address. All these information maps to A record, SRV and PTR field of DNS field. Any extra information can be filled in the TXT field of DNS which is in form of name=value, where first field needs to be "txtvers=1".

Publishing a service requires device to have server thread running in accept mode to accept connection from other devices using the port number advertised. A thread will handle new connections with each client. Message exchange will be of form xmpp message type, iq.

To use the service, device can resolve services advertised in form of "_presence._tcp". Once the device hosting this service is found, based on user preference, selection or previous decision connection is established between devices. The mDNS resolve contains enough information to establish socket communication with the device and start XMPP session.

A sample implementation overview is described below. It is one of the probable way of implementing communication with XMPP server.

<div class="uml">

actor George
autonumber
George -> George_Device: Start XMPP based Discovery
George_Device->mDNS_Server: Publish Service

note over mDNS_Server
 First start server using following set of calls: 1) socket(); bind(sd, address, len); listen(sd); peer_sd = accept(sd);
 Next publish service using Avahi API
 2)avahi_entry_group_add_service(…, user@machinename, SrvType (_presence._tcp), Port, TXT);
 3)avahi_entry_group_add_address(…,machinename.local, IPAddress);
end note

XDevice->mDNS_Server: Resolve service

note over XDevice
 use avahi to browse service: avahi_service_browser_new(SrvType(_presence._tcp), domain, callback);
end note

mDNS_Server-->XDevice: List of devices

note over mDNS_Server
 avahi call to resolve service: avahi_service_resolver_new(name, SrvType, domain)
end note

XDevice->George_Device: Establish Socket Connection
XDevice->George_Device: Initial Stream message

note over XDevice
 <stream from = ‘x@machine" to = ’george_device@machine’ xmlns=‘jabber:client’ xmlns:stream=‘’>
end note

George_Device-->XDevice: Stream response

note over George_Device
 <stream from = ’george_device@machine" to = ’x@machine’ xmlns=‘jabber:client’ xmlns:stream=‘’>
end note

</div>


In comparison to other service types available on ZeroConf, XMPP serverless provides service type, IP address and port that helps in establishing socket communication between two devices and then they can exchange messages based on XMPP. The advantage is no need for driver as two devices uses XMPP protocol to exchange messages.

Based on the above description, API and structure relevant to establish remote connection are presented below.

<pre><code class="c">
typedef struct remote_conn{

 // This will hold username in case of connection to XMPP server and nick in case of connecting to XMPP
 // serverless messaging
 char **username_nick;

 // Domain name where user is registered with and in XMPP serverless as a machine name
 char** domain_machinename;

 // Password required for connecting with XMPP server
 char* password;

 // If same resource is to be used with multiple resources, all resource information. This could be user input
 // or information is filled in automatically based on discoverable device configuration
 char **resources;
}RemoteConn;

// Error handling based on XMPP error message
// This call has to be called in order to establish communication with remote XMPP server and in case of Serverless
// Messaging this will be used to start services locally, advertise service, and connect to remote device.

int connect (RemoteConn *remote);
</code></pre>

h4. Query Information

The data structures defined support interfaces and devices. Each interface and discovery mechanism can be queried to get device specific information. Results might vary depending on device and mechanism used to find the device, for example USB discovery mechanism provides different information and if queried for device found through UPnP or ZeroConf information provided is different.

<pre><code class="c">
// Returns 1 if it meets filter option or else result will be based on interface results
// result will be based on format that developer can understand
int query (const char *device_interface, char *filter_option, char **result);

// Returns the IP address depending on the interface
char** getIPAddress(char *iface);
</code></pre>

h3. JavaScript APIs

Webinos provides a JavaScript Discovery API for web developers. The API provides functionality to search for services either remotely/locally and to instantiate an implementation of the API that hides the complexity of communicating with the remote service in a trusted manner. The API can be used to find service that are defined by Webinos but it is also possible for application developers to add own services and make those services discoverable. A service is made discoverable by an application developer using the webinos:shared element in the config.xml manifest as defined in "Exposing Application Functionalities as Services":http://dev.webinos.org/redmine/projects/wp3-1/wiki/Spec_-_Foundations#Exposing-Application-Functionalities-as-Service-to-other-Applications.

The Discovery API is defined in "Webinos Discovery":http://dev.webinos.org/specifications/draft/servicediscovery.html specification. The "Discovery Interface":http://dev.webinos.org/specifications/draft/servicediscovery.html#::discovery::DiscoveryInterface provides three methods that are used to find and create services:

* findServices(), to query for services
* createService(), to create a service with a given service identity
* getServiceId(), to get a unique identity of service that can be shared between two peers.

The search query is asynchronous and there will be a success callback for every service that is found. The time for finding services can vary significantly depending of which type of discovery method that is used, e.g. Bluetooth service discovery. An application must thereby be able to handle cases where the search query continues for a reasonable amount of time. The default max search query time is defined to 120 seconds.

The second part of the service discovery process is to Bind to the requested services. This method is implemented by the Service Interface as defined in "Service Interface":http://dev.webinos.org/specifications/draft/servicediscovery.html#::discovery::Service.

The Bind operation will mutually authenticate the application/service, verify access/privacy policies and instantiate an implementation of the API in asynchronous manner. Once the service binding has been successfully executed, the API will be ready to use by the application and the service object will act as a proxy to the remote peer. A more detailed example of how to use the API is available here "discovery code example":http://dev.webinos.org/specifications/draft/servicediscovery.html#::discovery::DiscoveryInterface

h3. Discovery of Personal Zone Hub

WebFinger will be used to discover the Personal Zone Hubs (PZH) from e-mail addresses, facebook identities or some other well-known identity. When a WebFinger request is issued with an user identity to a Webfinger service, the WebFinger service will return an "Extensible Resource Description (XRD)":http://docs.oasis-open.org/xri/xrd/v1.0/os/xrd-1.0-os.html with known services associated with this user identity. The PZH will be exposed in the XRD document as a host meta data element using the Link element where the ref attribute is assigned to http://webinos.org/spec/1.0. Example of the XRD document with a link to a PZH:

<pre><code class="javascript">
<?xml version=’1.0’?>
<XRD xmlns=’http://docs.oasis-open.org/ns/xri/xrd-1.0’>
<Link rel=’http://webinos.org/spec/1.0’ ref=’http://phz.example.org/profile/joe.smith’/>
</XRD>
</code></pre>

h3. Dependencies on other components

This section describes interfaces between discovery and following work areas:

* Event Handling

* ID Management

h5. Event Handling

Interfacing with event handling will mainly happen when
* There are changes in status of service or device, or in contextual aspects of a service or device being used
* New service becomes available. The new service could be a brand new one or could also possibly be a better replacement for the existing service.

Discovery requires event handling to provide the following interfaces:
* Device or service requester to register as event listener subscription to a certain event type
* Device or service publisher to send event
* Device or service requester to remove event listener

To be able to receive a certain class of notifications on the changes of status or context information of the service or device being used or to be informed about new services, the service or device requester needs to act as an event listener. To do this, the requester can subscribe to the event source with associated queries. Event source varies on different use cases. For example, in the case that George would like to be notified of the update on Paul’s MP4s, a possible implementation is to use publish/subscribe as follows:

<div class=“uml”>(

actor George
autonumber
George -> Public_Website:register/subscribe as event listener to receive "new MP4" notification

actor Paul
Paul -> Public_Website: Publish "new MP4" service

Public_Website -> George: Send "new MP4" notification

George -> Public_Website: remove event listener on "new MP4" notification

</div>

In this case, the notification is pushed to George’s Personal Zone Hub (PZH). George’s PZH will work out whether George prefers this notification being forwarded to the device he is using or to all his devices. Alternatively, in the case that Georgeâ€™s media player on mobile would like to know the updates of on the MP4 files on her PC, a Zone API shall be applied.

Some lower level discovery mechanisms have their own event handling mechanisms. For example, in UPnP, a control point can be registered at a service to be informed about device or service status changes. The service sends event messages to all registered control points after changing the value of a state variable. Event messages are transmitted via the Generic Event Notification Protocol (GENA) ([[Spec_-_Discovery#-COHEN11|COHEN11]]). In Webinos, service advertisement and service status update function shall be exposed as JavaScript APIs or JavaScript Object. These need to be supported by a lower level mechanism. A wrapper on the top of lower level event handling mechanism might be required in this case, for example, exposing an HTTP or web sockets or similar server as part of a plugin.


h5. ID Management

To discovery another personâ€™s zone, in another word, to acquire proxy object of another personâ€™s personal zone, a userid (or Zone ID) or information from where userid can be acquired should be provided. The userid information could be [i] email address; [ii] phone number; [iii] or just a text file etc. In whichever way, when userid is available, user should be able to locate or query service to determine their zone hub, further address devices based on their user information.

Due to the variation of interconnect mechanisms, device identity could be represented in different forms such as UUID in UPnP, MAC address in Bluetooth, some of them also presents friendly description, e.g. Markâ€™s PC, at the same time. The web developer, however, doesn’t want to know mechanism specific names or identities. This requires a genuine Identity/naming identity representation. Some discovery mechanisms, e.g. mDNS, allow user assign meaningful names to devices to replace the default names. A common naming scheme sitting on the top of different bearer schemes, will allows us to hide the under layer implementation details.

Device names should only be unique to the user they are associated. A good example on presenting userid and deviceid is a full Jabber ID: alice@gmail.com/mobile, which is a representation being used in XMPP description.

h3. Implementation Architecture

This section looks at the two levels of implementation APIs for different groups of discovery API users:

* Third party developers who would like to implement interfaces have APIs on the internetworking technologies they are interested
* Web developers who donâ€™t want to know the details of the bearers and use prefer to have generic structures for different discovery mechanisms.

Figure Implementation_1 & Figure Implementation_2 present the implementations architectures for both levels of APIs. For low level third party API, when native discovery APIs is not presented in Javascript, a wrapper is required. Whilst for high level APIs, a wrapper is essential in order to isolate the complexity of different internetworking technologies.

![](http://dev.webinos.org/redmine/attachments/635/high_level_implementation_arch1.png)
![](http://dev.webinos.org/redmine/attachments/636/low_level_implementation_arch1.png)

These two-level API infrastructure solutions will bring benefits such as
* Giving the freedom for third party developer to work on the specific networking technologies interested.
* Reducing effort on developing applications for web developers
* Isolating web developers from changes in networking technologies, addressing schemes and topologies

In this section, we will look at the implementation issues from the following aspects:
* Native code & APIs
* Exposing JavaScript APIs to third party developers
* Exposing JavaScript APIs to web developers

We take a simple use case, e.g. George wants to view his mobile hosted MP4s on his own or a friend’s set top box, to start our story on implementation.

h4. Aspect 1: Native code & APIs

h5. Local Discovery: Set Box can be reached via local connection. George to discover set box via local discovery â€“ Internet access is not essential.

Georgeâ€™s mobile scans for the set box with any of the following local discovery implementations:

h5. Avahi- Zeroconf implementation

Avahi is a ZeroConf implementation. It provides a good range of for multicast DNS/DNS-SD service discovery. It is under the GNU Lesser General Public License (LGPL). With the advantage being open source over Appleâ€™s Bojour implementation, Avahi had already become the de-facto standard implementation of mDNS/DNS-SD on free operating systems such as Linux.

Avahi provides a set of language bindings, e.g . python, C, C++. It ships with most Linux and **BSD distributions. Avahi source codes are available to download free online.

Following figure illustrated some main APIs used in avahi.

![](http://dev.webinos.org/redmine/attachments/696/Avahi_api.png)

Example code is available in our early demo - [http://www.w3.org/2011/04/discovery.html].


h5. UPnP implementations

There are a few UPnP open source implementations existing for Linux system, e.g. gupnp-tools and upnp-Inspector. These implementations may come with a lot dependencies, e.g. gupnp implementation depends heavily on glib. As SSDP in UPnP is not so complicated itself, an alternative way is to write our own SSDP codes, e.g. SSDP discovery source is available in our early demo http://www.w3.org/2011/04/discovery.html. It uses scan_ssdp to launch a thread to discover UPnP devices by sending SSDP M-SEARCH message over multicast UDP to 239.255.255.250:1900. It then listens for unicast responses and multicast notifications. When a new location is seen, a further thread is launched to retrieve the XML document describing the device’s services. This is then passed back to the web page script via the browser’s pluginthreadasynccall which calls the plugin on the UI thread, triggering a call back to the web page.

In local discovery mechanism availability of service description differs. ZeroConf publishes and resolve devices based on service type. Devices connect and bind to each other and then can exchange service description or driver to communicate. In contrast, UPnP mechanism makes service description available where UPnP based device has published device information; it is in form of web server. Though information about services is relevant after connecting, device can look into service information before deciding to connect to it. This feature is not present in ZeroConf. ZeroConf focuses on discovery aspect and defines only service type

In both Zeroconf and UPnP, service are described in .xml file. This should be mapped in to the service descriptions in Webinos config.xml manifest defines the services utilizing the webinos:shared element.

h5. BlueZ - Bluetooth

BlueZ is a widespread Bluetooth stack implementations initially developed by Qualcomm. It is included with the official Linux kernel distributions. As of 2006, the BlueZ stack supports all core Bluetooth protocols and layers. BlueZ provides a set of language bindings such as Python, C, Java, C++ etc.

The Host Controller Interface (HCI) socket in BlueZ provides a direct connection to the microcontroller on the local Bluetooth adapter. For tasks requiring precise control over the Bluetooth controller, such as asynchronous device discovery, HCI socket type shall be used. For a simple discovery procedure, the following APIs shall be available:
** Gets the device ID for a specified local HCI device. e.g. hci_get_route()
* Opens HCI socket associated with the device. e.g. hci_open_dev()
* Performs an HCI inquiry to discover Bluetooth devices. e.g. hci_inquiry().

An example code is available in our early demo - [http://www.w3.org/2011/04/discovery.html].

h5. OpenSLP â€“ SLP

The OpenSLP project is an effort to develop an open-source implementation of the IETF Service Location Protocol suitable for commercial and non-commercial application. It is under the Caldera Systems open source license - a license that is legally compatible with the popular BSD open source license[ http://www.openslp.org/]. OpenSLP is hosted by SourceForge.net and source code and binaries are free for download.

Main APIs correspond to service discovery are:

 * Registration - SLPReg (…, service_type, service_attribute, callback…);
 * Service find - SLPFindSrvs (…, service_type, filter, callback…);

An example code is also available in our early demo - [http://www.w3.org/2011/04/discovery.html].

h5. Local discovery with serverless XMPP - IP address is essential

To use XMPP for serverless messaging, ZeroConf is used to publish and resolve service. Once service is resolved and connected, XMPP is used for message exchange.

A typical implementation for third party developer will involve following function calls:
# connect( nick_name, last_name, …);
# start_server(port)
# avahi_entry_group_add_service (nick_name@machinename, srv_type(_presence._tcp), port)
# avahi_entry_group_add_address(…,machinename.local, IPAddress);
# avahi_service_browse_new(_presence._tcp)
# socket_bind(ipaddr_port);
# send_stanza(userid);

Calls are similar with server based XMPP except instead of DNS SRV, mDNS is used to locate services.
There are no identified open source implementations for XMPP Serverless Messaging. Initial implementation demo to experiment with the XMPP serverless messaging: [http://dev.webinos.org/redmine/attachments/662/xmpp_rfc6120_xep0174.zip].

h5. Remote discovery: The set box is remotely located from George’s Mobile or local discovery is not available. George to discover the set-top-box via Internet access

XMPP is used in this mechanism. The details described here are low level and protocol level and does not describe how webinos system will interact with web developer. The information is under hood work done by webinos platform.

A typical call flow for third party developer implementation
# connect(userid@domain/resource, password);
# ipaddr_port = resolve(domain);
# sock = socket_bind(ipaddr_port);
# bind_id = xmpp_stream_feature_exchange(sock, resource);
# send_presence_subscription_info(services);
# send_stanza(userid);

There are several open source implementation of XMPP core, libstrophe is implemented as C library and also as JavaScript library. As part of experimentation with XMPP, a demo initial implementation based on UML sequence diagram described in remote discovery of protocol definition was implemented. It is implementation in C as NPAPI plugin. It is limited in comparison to libstrophe but provides platform as a base for webinos platform.
[http://dev.webinos.org/redmine/attachments/662/xmpp_rfc6120_xep0174.zip].

h5. XmppDemo

Another XMPP implementation for service discovery was implemented in JavaScript. Purpose of this demo was to investigate the use of XMPP for webinos service discovery (as opposed to trying to implement webinos in javascript). Firstly, a tiny introduction to XMPP addressing:

> Within XMPP addressing is done using Jabber ID’s (in the early days before standardisation XMPP was called Jabber). A full Jabber ID - or JID - consists of a user part, a domain part and a resource, e.g. william@example.com/mobile. Users can be connected through multiple resources at the same time. If one addresses a user without a resource (e.g. send a message to william@example.com) this means that the server should determine at what resource the user is best reachable.

The demo setup is like this:

![](tno-xmppdemo-overview.png)

The above figure depicts two users w011 and w012 of which the first one uses two browser instances (for example one on a laptop and one on a mobile phone) and the second one uses just a single instance. Note that the demo easily supports dozens of people using multiple resources simultaneously, even though the figure contains a mere two users with three resources.

The demo supports freely chosen resource names (which are prefilled but changable):

![](tno-xmppdemo-login.png)

The user names and buddy lists are preconfigured and could be chosen from:
* w011@servicelab.org t/m w015@servicelab.org (friends group 1, personal zones 1..5 within that group)
* …
* w081@servicelab.org t/m w085@servicelab.org (friends group 2, personal zones 1..5 within that group)
Password for all users is webinos.

The browser runs a web application that is retrieved from the web server. This application consists of HTML, CSS and JavaScript. The web server doubles as a BOSH server that converts XMPP over HTTP (from and to the browser) to regular XMPP (from and to the XMPP server). In order to keep things clean and understandable the application is highly modularised as is shown here:

![](tno-xmppdemo-packages.png)

* xmppdemo.js contains the code for the application itself; setting up webinos, handlers and managing the user interface. It leans on the jQuery javascript library (see http://jquery.com/).
* webinos.js describes the interface, i.e. the way applications use webinos. In addition, it provides a model for services.
* webinos-impl.js contains the actual webinos implementation. As stated above, in the future webinos is not to be coded in javascript but purposes of the experiment it proved quite conventient. For communication with the server (using XMPP over HTTP or BOSH, see ) it uses the Strophe library (see http://strophe.im/strophejs/).

Part of the code (especially the debug console) is based on example code from the book "Professional XMPP Programming with JavaScript and jQuery" (http://professionalxmpp.com/). The full implementation can be obtained by accessing http://xmpp.servicelab.org/xmppdemo/. The javascript files are extensively commented.

Finally, some comments on what we have learned from this demo:
* XMPP architecture, naming and addressing map quite good on the webinos requirements
* The example build on the XEP-0115 specification for service discovery (http://xmpp.org/extensions/xep-0115.html), which is elegant and suitable, but
* does not scale very well. Some sort of ’intelligent massive service discovery’ extension should be designed specifically for webinos-like applications.

#### Aspect 2: Expose JavaScript APIs to third party developers

Because most local discovery libraries discussed above do not provide language bindings with JavaScript, a wrapper to map between the native code and JavaScript is required. One solution is to use a cross browser plugin. Following figure shows an example on exposing avahi_service_browser_new() api to a Javascript object using NPAPI. Refer section on plugin for more details on Browser plug-in/extension handling.

![](http://dev.webinos.org/redmine/attachments/697/Avahi_NPAPI.png)

In the case of using XMPP for local discovery, instead of scan, connect function is called with user details such as nickname, lastname, email or any other detail that would like to broadcast.

#### Aspect 3: Expose JavaScript APIs to web developers

The high level discovery implementation is to expose discovery interfaces, device and service features for different internetworking technologies to web developers and end users, ideally in JavaScript. This means to publish, find and bind services via web page scripts. The scripts listen for requests from other browsers and then respond in some manner. This might involve extensions on the current browsers with a server of some kind. An extension on browser is out of the scope of discovery and will not be discussed here.

Webinos has defined a set of high level service discovery APIs to find and bind services that are exposed locally or remotely. Local services include services exposed via local connectivityâ€™s such as BT, WiFI or USB whilst remote services cover services exposed within personal zone and cross personal zones for different users. Basically, the Webinos service discovery module enables web developers to find service (it includes devices) based on a certain search criteria. The found services are listed in a selection list in an asynchronous manner. Once the user selected a service, the implementation of the service is initiated by binding to the service. For further details on these APIs and example codes, please refer WP3.2 Discovery APIs.

References
----------

### COHEN11

J. Cohen, S. Aggarwal, Y. Y. Goland General Event Notification Architecture Internet Draft, 2000.

